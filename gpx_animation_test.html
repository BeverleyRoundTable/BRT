<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Turbo Santa GPX Animation</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" />
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#0b0d12}
#map{position:absolute;inset:0}
#anim{position:absolute;inset:0;pointer-events:none}
</style>
</head>

<body>
<div id="map"></div>
<canvas id="anim"></canvas>

<script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
<script>
/* ================= FLAGS ================= */
const PARAMS = new URLSearchParams(location.search);
const IS_RENDER = PARAMS.has("render");
const API = PARAMS.get("api");
const ROUTE = PARAMS.get("route");
window.__GPX_DONE__ = false;

if (!API) throw new Error("Missing ?api=");
if (!ROUTE) throw new Error("Missing ?route=");

/* ================= CANVAS ================= */
const canvas = document.getElementById("anim");
const ctx = canvas.getContext("2d");
let map = null, VIEW_W = 0, VIEW_H = 0;

function resize(){
  if(!map) return;
  const c = map.getCanvas();
  const dpr = devicePixelRatio || 1;
  VIEW_W = c.clientWidth;
  VIEW_H = c.clientHeight;
  canvas.width = VIEW_W * dpr;
  canvas.height = VIEW_H * dpr;
  canvas.style.width = VIEW_W + "px";
  canvas.style.height = VIEW_H + "px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
}

/* ================= MAP STYLE ================= */
const MAP_STYLE = {
  version:8,
  sources:{
    raster:{
      type:"raster",
      tiles:["https://basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}@2x.png"],
      tileSize:256
    }
  },
  layers:[{id:"base",type:"raster",source:"raster"}]
};

/* ================= MATH ================= */
const dist = (a,b)=>{
  const R=6371000;
  const dLat=(b.lat-a.lat)*Math.PI/180;
  const dLng=(b.lng-a.lng)*Math.PI/180;
  const s=Math.sin(dLat/2)**2+
          Math.cos(a.lat*Math.PI/180)*Math.cos(b.lat*Math.PI/180)*
          Math.sin(dLng/2)**2;
  return 2*R*Math.asin(Math.sqrt(s));
};

const bearing=(a,b)=>{
  const dLng=(b.lng-a.lng)*Math.PI/180;
  const y=Math.sin(dLng)*Math.cos(b.lat*Math.PI/180);
  const x=Math.cos(a.lat*Math.PI/180)*Math.sin(b.lat*Math.PI/180)-
          Math.sin(a.lat*Math.PI/180)*Math.cos(b.lat*Math.PI/180)*Math.cos(dLng);
  return (Math.atan2(y,x)*180/Math.PI+360)%360;
};

const lerpA=(a,b,t)=>a+(((b-a+540)%360)-180)*t;

function normalizeBearing(b){
  return (b % 360 + 360) % 360;
}

function signedAngleDelta(a, b) {
  return ((a - b + 540) % 360) - 180;
}

/* widened South bucket to stabilise West */
function bearingToRow(b){
  b = normalizeBearing(b);
  if (b >= 315 || b < 45)   return 0; // North
  if (b >= 45  && b < 135)  return 1; // East
  if (b >= 135 && b < 235)  return 2; // South
  return 3;                           // West
}

/* ================= LOAD ================= */
(async()=>{
  const master = await fetch(API,{cache:"no-store"}).then(r=>r.json());
  const s = master.settings || {};

  const r = master.routes.find(x =>
    x.routeName?.toLowerCase() === ROUTE.toLowerCase()
  );
  if (!r) throw new Error("Route not found: " + ROUTE);

  const rawPts = await fetch(r.gpxUrl)
    .then(r=>r.text())
    .then(x =>
      [...new DOMParser()
        .parseFromString(x,"text/xml")
        .getElementsByTagName("trkpt")]
      .map(p=>({
        lat:+p.getAttribute("lat"),
        lng:+p.getAttribute("lon")
      }))
    );

  if (!rawPts.length) throw new Error("GPX has no track points");

  const sprite = await new Promise(res=>{
    const i = new Image();
    i.onload = ()=>res(i);
    i.src = s.travelboast_sprite;
  });

  run(rawPts, sprite, s);
})();

/* ================= ANIMATION ================= */
function run(pts, sprite, s){
  map = new maplibregl.Map({
    container:"map",
    style:MAP_STYLE,
    center:[pts[0].lng, pts[0].lat],
    zoom:+s.default_map_zoom||16,
    bearing:0,
    pitch:IS_RENDER?48:52
  });

  const FOLLOW_ZOOM  = IS_RENDER ? 18.9 : 18.4;
  const FOLLOW_PITCH = IS_RENDER ? 48 : 52;

  const FRAMES     = +s.travelboast_sprite_frames || 5;
  const SPRITE_FPS = +s.travelboast_sprite_fps || 12;
  const BASE_SIZE  = +s.travelboast_sprite_size || 72;
  const YAW_DAMPING = 0.12;

  const OVERVIEW_PAN_MS  = 3500;
  const OVERVIEW_HOLD_MS = 5000;

  const FRAME_W = sprite.width / FRAMES;
  const FRAME_H = sprite.height / 4;

  const cum=[0];
  for(let i=1;i<pts.length;i++) cum[i]=cum[i-1]+dist(pts[i-1],pts[i]);
  const total=cum.at(-1);

  const DURATION_SEC = Math.max(1, +s.travelboast_speed || 60);

  const bounds = new maplibregl.LngLatBounds();
  pts.forEach(p=>bounds.extend([p.lng,p.lat]));

  let simTime=0;
  let sprB=bearing(pts[0],pts[1]||pts[0]), targetB=sprB;
  let spriteFrame=0, spriteTimer=0;
  let finished=false, overviewAt=null;

  let facingRow = bearingToRow(sprB); // ðŸ”’ row lock

  // --- PATCH: hard-lock window around West to prevent occasional escapes ---
  const WEST_LOCK_MIN = 255;
  const WEST_LOCK_MAX = 285;

  map.on("load",()=>{
    resize(); map.on("resize",resize);

    map.addSource("route",{type:"geojson",data:{type:"Feature",geometry:{type:"LineString",coordinates:[]}}});
    map.addLayer({id:"route",type:"line",source:"route",paint:{
      "line-color":s.primary_color||"#d31c1c",
      "line-width":6
    }});

    requestAnimationFrame(step);
  });

  function step(){
    const dtSim = 1/60;

    if (finished){
      if (performance.now()-overviewAt > OVERVIEW_PAN_MS+OVERVIEW_HOLD_MS){
        window.__GPX_DONE__=true;
        return;
      }
      requestAnimationFrame(step);
      return;
    }

    simTime+=dtSim;
    const m=Math.min(total,(simTime/DURATION_SEC)*total);

    let i=cum.findIndex(v=>v>=m); i=Math.max(1,i);
    const t=(m-cum[i-1])/(cum[i]-cum[i-1]||1);
    const a=pts[i-1], b=pts[i];
    const pos={lat:a.lat+(b.lat-a.lat)*t,lng:a.lng+(b.lng-a.lng)*t};

    targetB=bearing(a,b);
    sprB=lerpA(sprB,targetB,YAW_DAMPING);
    const normB = normalizeBearing(sprB);

    // --- PATCH: diagonal bias + hard west lock + hysteresis ---
    let desiredRow = bearingToRow(normB);

    // Diagonal bias: prefer N for NE/NW; prefer S for SE/SW
    if (normB > 300 || normB < 60) desiredRow = 0;
    else if (normB > 120 && normB < 240) desiredRow = 2;

    // Hard West lock near 270Â°
    if (normB >= WEST_LOCK_MIN && normB <= WEST_LOCK_MAX) desiredRow = 3;

    const rowFacingAngles=[0,90,180,270];
    const delta=Math.abs(signedAngleDelta(
      rowFacingAngles[desiredRow],
      rowFacingAngles[facingRow]
    ));
    if(delta>35) facingRow=desiredRow;

    let yaw=signedAngleDelta(normB,rowFacingAngles[facingRow]);
    if(Math.abs(yaw)<6) yaw=0;
    yaw*=0.6;
    yaw=Math.max(-15,Math.min(15,yaw));
    const rotationRad=yaw*Math.PI/180;

    spriteTimer+=dtSim;
    if(spriteTimer>=1/SPRITE_FPS){
      spriteTimer-=1/SPRITE_FPS;
      spriteFrame=(spriteFrame+1)%FRAMES;
    }

    map.getSource("route").setData({
      type:"Feature",
      geometry:{type:"LineString",coordinates:[
        ...pts.slice(0,i).map(p=>[p.lng,p.lat]),
        [pos.lng,pos.lat]
      ]}
    });

    map.jumpTo({center:[pos.lng,pos.lat],zoom:FOLLOW_ZOOM,bearing:0,pitch:FOLLOW_PITCH});

    ctx.clearRect(0,0,VIEW_W,VIEW_H);
    const p=map.project([pos.lng,pos.lat]);

    const SIZE=BASE_SIZE*(0.9+Math.min(0.4,(FOLLOW_ZOOM-15)*0.25));
    const sx=spriteFrame*FRAME_W;
    const sy=facingRow*FRAME_H;

    ctx.save();
    ctx.translate(Math.round(p.x),Math.round(p.y));
    ctx.rotate(rotationRad);
    ctx.drawImage(sprite,sx,sy,FRAME_W,FRAME_H,-SIZE/2,-SIZE/2,SIZE,SIZE);
    ctx.restore();

    if(m>=total){
      finished=true;
      map.fitBounds(bounds,{padding:120,pitch:0,bearing:0,duration:OVERVIEW_PAN_MS,maxZoom:14});
      overviewAt=performance.now();
    }

    requestAnimationFrame(step);
  }
}
</script>
</body>
</html>
