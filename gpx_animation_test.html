<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Santa GPX TravelBoast Style</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

<style>
html, body {
  margin: 0; padding: 0; height: 100%;
  background: #0b0d12;
  overflow: hidden;
  font-family: system-ui, -apple-system, BlinkMacSystemFont,
               "Segoe UI", Roboto, sans-serif;
}
#map { position:absolute; inset:0; z-index:1; }
#anim { position:absolute; inset:0; z-index:10; pointer-events:none; }

#ui-layer {
  position:absolute;
  bottom:24px;
  left:50%;
  transform:translateX(-50%);
  z-index:20;
  pointer-events:none;
  text-align:center;
}
.pill {
  background:rgba(0,0,0,.65);
  color:#fff;
  padding:10px 20px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.2);
  box-shadow:0 6px 16px rgba(0,0,0,.45);
  backdrop-filter:blur(6px);
}
#route-name { margin:0; font-size:1rem; font-weight:600; }
#route-date { margin:2px 0 0; font-size:.8rem; opacity:.8; }
</style>
</head>

<body>
<div id="map"></div>
<canvas id="anim"></canvas>

<div id="ui-layer">
  <div class="pill">
    <h1 id="route-name">Loading route…</h1>
    <p id="route-date"></p>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/* ------------------------------------------------------------
   PARAMS
------------------------------------------------------------ */
const P = new URLSearchParams(location.search);
const API   = P.get("api");
const ROUTE = P.get("route");

if (!API) {
  document.body.innerHTML =
    "<h2 style='padding:20px;color:#fff'>❌ Missing api= parameter</h2>";
  throw new Error("Missing api");
}

/* ------------------------------------------------------------
   CANVAS (DPR)
------------------------------------------------------------ */
const canvas = document.getElementById("anim");
const ctx = canvas.getContext("2d");

function resizeCanvas(){
  const dpr = window.devicePixelRatio || 1;
  canvas.width = innerWidth * dpr;
  canvas.height = innerHeight * dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resizeCanvas);
resizeCanvas();

/* ------------------------------------------------------------
   MAP
------------------------------------------------------------ */
const map = L.map("map", {
  zoomControl:false,
  attributionControl:true
});

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  maxZoom:20
}).addTo(map);

/* ------------------------------------------------------------
   HELPERS
------------------------------------------------------------ */
async function fetchJSON(url){
  const r = await fetch(url,{cache:"no-store"});
  if(!r.ok) throw new Error("API fetch failed");
  return r.json();
}

async function loadGPX(url){
  const xml = await (await fetch(url,{cache:"no-store"})).text();
  const dom = new DOMParser().parseFromString(xml,"text/xml");
  return [...dom.getElementsByTagName("trkpt")].map(p=>({
    lat:+p.getAttribute("lat"),
    lng:+(p.getAttribute("lon")||p.getAttribute("lng"))
  }));
}

function smoothPath(points, it=2){
  if(it<=0||points.length<3) return points;
  let out=[points[0]];
  for(let i=0;i<points.length-1;i++){
    const a=points[i], b=points[i+1];
    out.push({lat:.75*a.lat+.25*b.lat,lng:.75*a.lng+.25*b.lng});
    out.push({lat:.25*a.lat+.75*b.lat,lng:.25*a.lng+.75*b.lng});
  }
  out.push(points.at(-1));
  return smoothPath(out,it-1);
}

function getAngle(a,b){ return Math.atan2(b.y-a.y,b.x-a.x); }
function lerpAngle(a,b,t){
  const d=(b-a+Math.PI)%(2*Math.PI)-Math.PI;
  return a+d*t;
}

/* ------------------------------------------------------------
   PARTICLES
------------------------------------------------------------ */
const SPARKLES_PER_FRAME = 3;
const sparkles = [];

class Sparkle {
  constructor(x,y){
    this.x=x+(Math.random()-.5)*10;
    this.y=y+(Math.random()-.5)*10;
    this.vx=(Math.random()-.5)*.6;
    this.vy=(Math.random()-.5)*.6;
    this.life=1;
    this.decay=.02+Math.random()*.03;
    this.size=1+Math.random()*3;
  }
  update(){ this.x+=this.vx; this.y+=this.vy; this.life-=this.decay; }
  draw(ctx){
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
    ctx.fill();
  }
}

/* Foreground snow */
const snow = [];
class Snow {
  constructor(){
    this.x=Math.random()*innerWidth;
    this.y=-20;
    this.size=4+Math.random()*6;
    this.speed=.6+Math.random()*1.2;
    this.drift=(Math.random()-.5)*.4;
  }
  update(){ this.y+=this.speed; this.x+=this.drift; }
  draw(ctx){
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
    ctx.fillStyle="rgba(255,255,255,.55)";
    ctx.fill();
  }
}

/* ------------------------------------------------------------
   MAIN
------------------------------------------------------------ */
(async()=>{
try{
  const master = await fetchJSON(API);
  const settings = master.settings||{};
  const routes = master.routes||[];

  const route = ROUTE
    ? routes.find(r=>r.routeName?.toLowerCase()===ROUTE.toLowerCase())
    : routes[0];

  if(!route) throw "Route not found";

  routeName.textContent = route.routeName||"";
  routeDate.textContent = route.date||"";

  let pts = smoothPath(await loadGPX(route.gpxUrl),3);
  const bounds = L.latLngBounds(pts.map(p=>[p.lat,p.lng]));
  map.fitBounds(bounds,{padding:[40,40]});
  setTimeout(()=>map.setZoom((+settings.default_map_zoom||16)),200);

  const sprite = new Image();
  sprite.crossOrigin="anonymous";
  sprite.src = settings.travelboost_sprite;
  await new Promise(r=>sprite.onload=r);

  startAnimation(pts,sprite,settings);

}catch(e){
  console.error(e);
  routeName.textContent="Error";
}})();

/* ------------------------------------------------------------
   ANIMATION
------------------------------------------------------------ */
function startAnimation(latLngs,sprite,settings){
let dist=0,last=0,angle=0;
let camLat=latLngs[0].lat, camLng=latLngs[0].lng;

const frames=+settings.travelboost_sprite_frames||5;
const fps=+settings.travelboost_sprite_fps||14;
const size=+settings.travelboost_sprite_size||128;
const speed=(+settings.travelboost_speed||.1)*.0016;

const accent=settings.travelboost_accent_color||"#ffd700";
const spriteW=sprite.width/frames;

function frame(ts){
  if(!last) last=ts;
  const dt=ts-last; last=ts;

  ctx.clearRect(0,0,canvas.width,canvas.height);

  dist=Math.min(dist+speed*dt,latLngs.length-1);
  const i=Math.floor(dist), t=dist-i;
  const a=latLngs[i], b=latLngs[Math.min(i+1,latLngs.length-1)];
  const lat=a.lat+(b.lat-a.lat)*t;
  const lng=a.lng+(b.lng-a.lng)*t;

  /* camera easing + offset confirm */
  const p=map.latLngToContainerPoint([lat,lng]);
  const off=map.containerPointToLatLng([p.x,p.y+innerHeight*.18]);
  camLat+= (off.lat-camLat)*.08;
  camLng+= (off.lng-camLng)*.08;
  map.panTo([camLat,camLng],{animate:false});

  const cur=map.latLngToContainerPoint([lat,lng]);
  const p1=map.latLngToContainerPoint(a);
  const p2=map.latLngToContainerPoint(b);

  /* fading trail */
  const start=Math.max(0,i-140);
  ctx.lineCap="round"; ctx.lineWidth=6;
  ctx.shadowColor=accent; ctx.shadowBlur=18;
  for(let j=start;j<i;j++){
    ctx.globalAlpha=(j-start)/140;
    const pa=map.latLngToContainerPoint(latLngs[j]);
    const pb=map.latLngToContainerPoint(latLngs[j+1]);
    ctx.strokeStyle=accent;
    ctx.beginPath(); ctx.moveTo(pa.x,pa.y); ctx.lineTo(pb.x,pb.y); ctx.stroke();
  }
  ctx.globalAlpha=1;

  /* sparkles */
  ctx.fillStyle=accent;
  for(let s=0;s<SPARKLES_PER_FRAME;s++) sparkles.push(new Sparkle(cur.x,cur.y));
  for(let k=sparkles.length-1;k>=0;k--){
    sparkles[k].update();
    sparkles[k].draw(ctx);
    if(sparkles[k].life<=0) sparkles.splice(k,1);
  }

  /* snow foreground */
  if(Math.random()<.12) snow.push(new Snow());
  for(let k=snow.length-1;k>=0;k--){
    snow[k].update(); snow[k].draw(ctx);
    if(snow[k].y>innerHeight+40) snow.splice(k,1);
  }

  /* sprite */
  angle=lerpAngle(angle,getAngle(p1,p2),.18);
  const frameIndex=Math.floor(ts/1000*fps)%frames;
  const bob=Math.sin(ts/140)*2;

  ctx.save();
  ctx.translate(cur.x,cur.y);
  ctx.rotate(angle+Math.PI/2);
  ctx.drawImage(sprite,
    frameIndex*spriteW,0,spriteW,sprite.height,
    -size/2,-size/2+bob,size,size);
  ctx.restore();

  if(dist<latLngs.length-1) requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
}
</script>
</body>
</html>
