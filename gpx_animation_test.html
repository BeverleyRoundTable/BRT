<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Santa Sleigh GPX Animation</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    /* Changed background to light grey for standard map feel */
    background: #e0e0e0; overflow: hidden; font-family: sans-serif;
  }
  #map { position: absolute; inset: 0; z-index: 1; background: #e0e0e0; }
  #anim { position: absolute; inset: 0; z-index: 10; pointer-events: none; }
  
  /* UI Layer */
  #ui-layer {
    position: absolute; bottom: 30px; left: 50%;
    transform: translateX(-50%);
    z-index: 20; text-align: center;
    pointer-events: none;
  }
  .pill {
    background: rgba(255, 255, 255, 0.9); /* Lighter pill for normal map */
    backdrop-filter: blur(4px);
    border: 1px solid rgba(0,0,0,0.1);
    color: #333; /* Dark text */
    padding: 10px 20px;
    border-radius: 50px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    display: inline-block;
  }
  h1 { margin: 0; font-size: 1.1rem; font-weight: 600; letter-spacing: 0.5px; }
  p { margin: 4px 0 0 0; font-size: 0.85rem; opacity: 0.8; }
</style>
</head>
<body>

<div id="map"></div>
<canvas id="anim"></canvas>

<div id="ui-layer">
  <div class="pill">
    <h1 id="route-name">Loading Santa...</h1>
    <p id="route-date"></p>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/* ------------------------------------------------------------
   CONFIGURATION & PARSING
------------------------------------------------------------ */
const P = new URLSearchParams(location.search);
const API = P.get("api");
const ROUTE_PARAM = P.get("route");
const CAM_FOLLOW = true; 

if (!API) {
  document.querySelector(".pill").innerHTML = "Error: Missing ?api= parameter";
  throw new Error("Missing API");
}

/* ------------------------------------------------------------
   CANVAS & MAP SETUP
------------------------------------------------------------ */
const canvas = document.getElementById("anim");
const ctx = canvas.getContext("2d");

function resizeCanvas() {
  canvas.width  = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  ctx.scale(devicePixelRatio, devicePixelRatio);
  canvas.style.width = window.innerWidth + "px";
  canvas.style.height = window.innerHeight + "px";
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// Initialize Leaflet
const map = L.map("map", { 
  zoomControl: false, 
  attributionControl: false,
  zoomAnimation: true
});

// ★ CHANGED: Standard OpenStreetMap Tiles (Normal Colour)
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

/* ------------------------------------------------------------
   DATA FETCHING
------------------------------------------------------------ */
async function fetchJSON(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error("Fetch error: " + r.status);
  return r.json();
}

async function loadGPX(url) {
  const xml = await (await fetch(url)).text();
  const parser = new DOMParser();
  const doc = parser.parseFromString(xml, "application/xml");
  const trkpts = Array.from(doc.querySelectorAll("trkpt"));
  
  if (trkpts.length === 0) throw new Error("No track points found in GPX");

  return trkpts.map(pt => ({
    lat: parseFloat(pt.getAttribute("lat")),
    lng: parseFloat(pt.getAttribute("lon"))
  }));
}

/* ------------------------------------------------------------
   GEOMETRY HELPERS
------------------------------------------------------------ */
function smoothPath(points, iterations = 2) {
  if (iterations === 0) return points;
  let smoothed = [];
  smoothed.push(points[0]);
  for (let i = 0; i < points.length - 1; i++) {
    const p0 = points[i];
    const p1 = points[i+1];
    smoothed.push({
      lat: 0.75 * p0.lat + 0.25 * p1.lat,
      lng: 0.75 * p0.lng + 0.25 * p1.lng
    });
    smoothed.push({
      lat: 0.25 * p0.lat + 0.75 * p1.lat,
      lng: 0.25 * p0.lng + 0.75 * p1.lng
    });
  }
  smoothed.push(points[points.length - 1]);
  return smoothPath(smoothed, iterations - 1);
}

function getAngle(p1, p2) {
  return Math.atan2(p2.y - p1.y, p2.x - p1.x);
}

function lerpAngle(a, b, t) {
  const diff = b - a;
  const da = (diff + Math.PI) % (2 * Math.PI) - Math.PI;
  return a + da * t;
}

/* ------------------------------------------------------------
   MAIN LOGIC
------------------------------------------------------------ */
(async function main() {
  try {
    const master = await fetchJSON(API);
    const settings = master.settings;
    const routes = master.routes;
    
    const routeData = routes.find(r => 
      (r.routeName || "").toLowerCase() === (ROUTE_PARAM || "").toLowerCase()
    );

    if (!routeData) throw new Error("Route not found: " + ROUTE_PARAM);

    document.getElementById("route-name").textContent = routeData.routeName;
    document.getElementById("route-date").textContent = routeData.date || "";

    let rawPoints = await loadGPX(routeData.gpxUrl);
    const pathPoints = smoothPath(rawPoints, 2); 

    const bounds = L.latLngBounds(pathPoints.map(p => [p.lat, p.lng]));
    map.fitBounds(bounds, { padding: [50, 50], animate: false });

    const sprite = new Image();
    sprite.crossOrigin = "anonymous";
    sprite.src = settings.travelboost_sprite;
    await new Promise(r => sprite.onload = r);

    requestAnimationFrame((ts) => 
      animate(ts, pathPoints, sprite, settings)
    );

  } catch (e) {
    document.querySelector(".pill").innerHTML = 
      `<span style='color:#ff6b6b'>Error: ${e.message}</span>`;
    console.error(e);
  }
})();

/* ------------------------------------------------------------
   ANIMATION LOOP
------------------------------------------------------------ */
let startTime = null;
let currentDist = 0;
let currentAngle = 0;

function animate(timestamp, latLngs, sprite, settings) {
  if (!startTime) startTime = timestamp;
  
  const fps      = Number(settings.travelboost_sprite_fps)   || 14;
  const frames   = Number(settings.travelboost_sprite_frames)|| 1; 
  const baseSize = Number(settings.travelboost_sprite_size)  || 64;
  const speed    = (Number(settings.travelboost_speed)       || 1.5) * 0.0001; 
  // ★ CHANGED: Default accent is now RED for visibility on white map
  const accent   = settings.travelboost_accent_color || "#d31c1c";
  const shadowOn = String(settings.travelboost_shadow).toLowerCase() === "true";

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Advance Position
  currentDist += speed * (60 / 1000 * 16); 
  if (currentDist >= latLngs.length - 1) {
    currentDist = latLngs.length - 1;
  }

  const idx = Math.floor(currentDist);
  const t = currentDist - idx;
  const p1_ll = latLngs[idx];
  const p2_ll = latLngs[Math.min(idx + 1, latLngs.length - 1)];

  const p1_px = map.latLngToContainerPoint(p1_ll);
  const p2_px = map.latLngToContainerPoint(p2_ll);

  const currentPx = {
    x: p1_px.x + (p2_px.x - p1_px.x) * t,
    y: p1_px.y + (p2_px.y - p1_px.y) * t
  };

  // Camera Follow
  if (CAM_FOLLOW && currentDist < latLngs.length - 1) {
    // Optional: map.panTo(...)
  }

  // Draw Trail
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  
  if (shadowOn) {
    ctx.shadowBlur = 10;
    ctx.shadowColor = accent;
  }
  
  ctx.strokeStyle = accent;
  ctx.lineWidth = 6; // ★ CHANGED: Thicker line for better visibility
  ctx.beginPath();
  
  // ★ CHANGED: Draw full path from index 0 (No fading tail)
  // This ensures the line "populates" and stays on the map
  const startPix = map.latLngToContainerPoint(latLngs[0]);
  ctx.moveTo(startPix.x, startPix.y);

  for (let i = 1; i <= idx; i++) {
    const px = map.latLngToContainerPoint(latLngs[i]);
    ctx.lineTo(px.x, px.y);
  }
  ctx.lineTo(currentPx.x, currentPx.y);
  ctx.stroke();
  
  ctx.shadowBlur = 0;

  // Draw Sprite
  const targetAngle = getAngle(p1_px, p2_px);
  
  const distSq = (p2_px.x-p1_px.x)**2 + (p2_px.y-p1_px.y)**2;
  if (distSq > 1) {
     currentAngle = lerpAngle(currentAngle, targetAngle, 0.1);
  }

  const totalSpriteWidth = sprite.width;
  const frameWidth = totalSpriteWidth / frames;
  const frameHeight = sprite.height;
  const currentFrameIdx = Math.floor((timestamp / 1000) * fps) % frames;

  ctx.save();
  ctx.translate(currentPx.x, currentPx.y);
  
  // ★ CHANGED: Add 90 degrees (Math.PI/2) to rotation
  // Because your new sprite faces UP/North, but code expects RIGHT/East
  ctx.rotate(currentAngle + Math.PI / 2);
  
  const drawW = baseSize;
  const drawH = drawW * (frameHeight / frameWidth);
  
  ctx.drawImage(
    sprite, 
    currentFrameIdx * frameWidth, 0, frameWidth, frameHeight,
    -drawW/2, -drawH/2, drawW, drawH 
  );
  
  ctx.restore();

  if (currentDist < latLngs.length - 1) {
    requestAnimationFrame((ts) => animate(ts, latLngs, sprite, settings));
  }
}
</script>

</body>
</html>
