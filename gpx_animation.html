<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Turbo Santa GPX Animation</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" />
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#0b0d12}
  #map{position:absolute;inset:0}
  #anim{position:absolute;inset:0;pointer-events:none}
</style>
</head>

<body>
<div id="map"></div>
<canvas id="anim"></canvas>

<script>
  window.__GPX_READY__ = false;
  window.__GPX_DONE__  = false;
  window.__RENDER_FRAME__ = 0;
</script>

<script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
<script>
const PARAMS    = new URLSearchParams(location.search);
const IS_RENDER = PARAMS.has("render");
const API       = PARAMS.get("api");
const ROUTE     = PARAMS.get("route");

if (!API)   throw new Error("Missing ?api=");
if (!ROUTE) throw new Error("Missing ?route=");

const canvas = document.getElementById("anim");
const ctx    = canvas.getContext("2d");

let map = null, VIEW_W = 0, VIEW_H = 0;

function resize(){
  if(!map) return;
  const c = map.getCanvas();
  const dpr = IS_RENDER ? 1 : (devicePixelRatio || 1);
  VIEW_W = c.clientWidth;
  VIEW_H = c.clientHeight;
  canvas.width  = VIEW_W * dpr;
  canvas.height = VIEW_H * dpr;
  canvas.style.width  = VIEW_W + "px";
  canvas.style.height = VIEW_H + "px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
}

const MAP_STYLE = {
  version: 8,
  sources: {
    raster: {
      type: "raster",
      tiles: ["https://basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}@2x.png"],
      tileSize: 256
    }
  },
  layers: [{ id: "base", type: "raster", source: "raster" }]
};

/* ================= MATH ================= */
const dist=(a,b)=>{
  const R=6371000;
  const dLat=(b.lat-a.lat)*Math.PI/180;
  const dLng=(b.lng-a.lng)*Math.PI/180;
  const s=Math.sin(dLat/2)**2+
    Math.cos(a.lat*Math.PI/180)*Math.cos(b.lat*Math.PI/180)*
    Math.sin(dLng/2)**2;
  return 2*R*Math.asin(Math.sqrt(s));
};

const bearing=(a,b)=>{
  const dLng=(b.lng-a.lng)*Math.PI/180;
  const y=Math.sin(dLng)*Math.cos(b.lat*Math.PI/180);
  const x=Math.cos(a.lat*Math.PI/180)*Math.sin(b.lat*Math.PI/180)-
          Math.sin(a.lat*Math.PI/180)*Math.cos(b.lat*Math.PI/180)*Math.cos(dLng);
  return (Math.atan2(y,x)*180/Math.PI+360)%360;
};

const normalizeBearing=b=>(b%360+360)%360;
const lerpAngle=(a,b,t)=>a+(((b-a+540)%360)-180)*t;

/* ================= SPRITE ROWS ================= */
function bearingToRowRaw(b){
  b=normalizeBearing(b);
  if(b>=337.5||b<22.5) return 0;
  if(b>=22.5&&b<67.5) return 1;
  if(b>=292.5&&b<337.5) return 1;
  if(b>=67.5&&b<112.5) return 2;
  if(b>=247.5&&b<292.5) return 2;
  if(b>=112.5&&b<157.5) return 3;
  if(b>=202.5&&b<247.5) return 3;
  return 4;
}

const ROW_CENTERS = [
  0,    // Row 0 → North
  45,   // Row 1 → North-East (mirrors to NW)
  90,   // Row 2 → East (mirrors to West)
  225,  // Row 3 → South-West (mirrors to SE)
  180   // Row 4 → South
];
const ROW_HYST=18;

const angularDistance=(a,b)=>Math.abs(((a-b+540)%360)-180);

function stableRow(prev,b){
  b=normalizeBearing(b);
  let best=prev;
  let bestD=angularDistance(b,ROW_CENTERS[prev]);
  if(bestD<ROW_HYST) return prev;
  for(let r=0;r<ROW_CENTERS.length;r++){
    const d=angularDistance(b,ROW_CENTERS[r]);
    if(d<bestD){bestD=d;best=r;}
  }
  return best;
}

(async()=>{
  const master=await fetch(API,{cache:"no-store"}).then(r=>r.json());
  const s=master.settings||{};
  const routeObj=(master.routes||[]).find(r=>String(r.routeName||"").toLowerCase()===ROUTE.toLowerCase());
  if(!routeObj) throw new Error("Route not found");

  const pts=await fetch(routeObj.gpxUrl)
    .then(r=>r.text())
    .then(x=>[...new DOMParser().parseFromString(x,"text/xml").getElementsByTagName("trkpt")]
      .map(p=>({lat:+p.getAttribute("lat"),lng:+p.getAttribute("lon")})));

  const sprite=await new Promise(res=>{
    const i=new Image();
    i.crossOrigin="anonymous";
    i.onload=()=>res(i);
    i.onerror=()=>res(null);
    i.src=s.travelboast_sprite;
  });

  run(pts,sprite,s);
})();

let started=false;

function run(pts,sprite,s){
  let mapIdle = false;

  /* PATCH: render pan state */
  let panStartFrame = null;
  let panFrom = null;
  let panTo = null;

  map=new maplibregl.Map({
    container:"map",
    style:MAP_STYLE,
    center:[pts[0].lng,pts[0].lat],
    zoom:+s.default_map_zoom||16,
    pitch:IS_RENDER?48:52,
    fadeDuration:0
  });

  const FOLLOW_ZOOM=IS_RENDER?18.1:17.9;
  const FOLLOW_PITCH=IS_RENDER?48:52;

  const FRAMES=+s.travelboast_sprite_frames||5;
  const BASE_SIZE=+s.travelboast_sprite_size||72;

  const FRAME_W=sprite?sprite.width/FRAMES:0;
  const FRAME_H=sprite?sprite.height/5:0;

  const STRIDE_METERS=1.6;
  const MIN_FPS=8,MAX_FPS=12;
  const BEARING_DAMP=0.18;

  const TRAVEL_SECONDS=Math.max(1,+s.travelboast_speed||45);
  const PAN_SECONDS=8;
  const RENDER_FPS=24;

  const cum=[0];
  for(let i=1;i<pts.length;i++) cum[i]=cum[i-1]+dist(pts[i-1],pts[i]);
  const total=cum.at(-1);

  let spriteTimer=0,spriteFrame=0;
  let smoothedB=bearing(pts[0],pts[1]||pts[0]);
  let facingRow=bearingToRowRaw(smoothedB);

  let simTime=0,lastTs=performance.now();
  let finished=false,finishTime=null,panStarted=false;
  let hideSanta=false;
  let hasDrawnFirstFrame=false;

  function start(){
    if(started) return;
    started=true;
    requestAnimationFrame(()=>requestAnimationFrame(step));
  }

  map.on("load",()=>{
    resize();
    map.on("resize",resize);
    map.once("idle",()=>mapIdle=true);

    map.addSource("route",{type:"geojson",data:{type:"Feature",geometry:{type:"LineString",coordinates:[]}}});
    map.addLayer({id:"route",type:"line",source:"route",paint:{
      "line-color":s.primary_color||"#d31c1c","line-width":6
    }});

    start();
  });

  function step(){
    if(IS_RENDER){
      simTime=(window.__RENDER_FRAME__||0)/RENDER_FPS;
    }else{
      const now=performance.now();
      simTime+=Math.min((now-lastTs)/1000,1/30);
      lastTs=now;
    }

    if(finished){
      if(IS_RENDER && panStartFrame!==null){
        const f=window.__RENDER_FRAME__-panStartFrame;
        const t=Math.min(1,f/(PAN_SECONDS*RENDER_FPS));
        map.jumpTo({
          center:[
            panFrom.lng+(panTo.lng-panFrom.lng)*t,
            panFrom.lat+(panTo.lat-panFrom.lat)*t
          ],
          zoom:FOLLOW_ZOOM*(1-t)+14*t,
          pitch:FOLLOW_PITCH*(1-t),
          bearing:0
        });
      }
      if(IS_RENDER&&simTime-finishTime>=PAN_SECONDS){
        window.__GPX_DONE__=true;return;
      }
      requestAnimationFrame(step);return;
    }

    const travelT=Math.min(1,simTime/TRAVEL_SECONDS);
    const m=travelT*total;
    let i=cum.findIndex(v=>v>=m); i=Math.max(1,i);
    const t=(m-cum[i-1])/(cum[i]-cum[i-1]||1);

    const a=pts[i-1],b=pts[i];
    const pos={lat:a.lat+(b.lat-a.lat)*t,lng:a.lng+(b.lng-a.lng)*t};

    smoothedB=lerpAngle(smoothedB,bearing(a,b),BEARING_DAMP);
    facingRow=stableRow(facingRow,smoothedB);

    const cadence=Math.max(MIN_FPS,Math.min(MAX_FPS,((total/TRAVEL_SECONDS)/STRIDE_METERS)*FRAMES));
    if(IS_RENDER){
      spriteFrame=Math.floor((window.__RENDER_FRAME__||0)/Math.max(1,Math.round(RENDER_FPS/cadence)))%FRAMES;
    }else{
      spriteTimer+=1/60;
      if(spriteTimer>=1/cadence){spriteTimer-=1/cadence;spriteFrame=(spriteFrame+1)%FRAMES;}
    }

    map.getSource("route")?.setData({
      type:"Feature",
      geometry:{type:"LineString",coordinates:[
        ...pts.slice(0,i).map(p=>[p.lng,p.lat]),
        [pos.lng,pos.lat]
      ]}
    });

    map.jumpTo({center:[pos.lng,pos.lat],zoom:FOLLOW_ZOOM,pitch:FOLLOW_PITCH,bearing:0});

    ctx.clearRect(0,0,VIEW_W,VIEW_H);
    const p=map.project([pos.lng,pos.lat]);
    const SIZE=BASE_SIZE*(0.9+Math.min(0.4,(FOLLOW_ZOOM-15)*0.25));

    if(sprite&&!hideSanta){
     // determine if sprite needs horizontal mirroring
let flip = false;

switch (facingRow) {
  case 1: // NE base → flip for NW
    flip = smoothedB >= 292.5 && smoothedB < 337.5;
    break;

  case 2: // E base → flip for W
    flip = smoothedB >= 247.5 && smoothedB < 292.5;
    break;

  case 3: // SW base → flip for SE
    flip = smoothedB >= 112.5 && smoothedB < 157.5;
    break;
}

ctx.save();
ctx.translate(p.x, p.y);
if (flip) ctx.scale(-1, 1);

ctx.drawImage(
  sprite,
  spriteFrame * FRAME_W,
  facingRow * FRAME_H,
  FRAME_W,
  FRAME_H,
  -SIZE / 2,
  -SIZE * 0.85,
  SIZE,
  SIZE
);

ctx.restore();

      if(!hasDrawnFirstFrame&&(!IS_RENDER?mapIdle:true)){
        hasDrawnFirstFrame=true;
        window.__GPX_READY__=true;
      }
    }

    if(travelT>=1&&!panStarted){
  panStarted = true;
  finishTime = simTime;

  const bounds = new maplibregl.LngLatBounds(
    pts.map(p => [p.lng, p.lat])
  );

  if (IS_RENDER) {
    panStartFrame = window.__RENDER_FRAME__ || 0;
    panFrom = map.getCenter();
    panTo = bounds.getCenter();

    hideSanta = true; // ✅ PATCH: hide Santa for render-pan frames
  } else {
    hideSanta = true;
    map.fitBounds(bounds, {
      padding:120,
      pitch:0,
      bearing:0,
      duration:PAN_SECONDS*1000,
      maxZoom:14
    });
  }

  finished = true;
}

    requestAnimationFrame(step);
  }
}
</script>
</body>
</html>
