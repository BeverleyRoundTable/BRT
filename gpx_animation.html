<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Santa Sleigh GPX Animation</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: #000; overflow: hidden;
  }
  #map { position: absolute; inset: 0; z-index: 1; }
  #anim { position: absolute; inset: 0; z-index: 10; pointer-events: none; }
  #label {
    position: absolute; bottom: 12px; left: 50%;
    transform: translateX(-50%);
    color: white; font-family: system-ui, sans-serif;
    text-shadow: 0 0 6px black; z-index: 20;
  }
</style>
</head>
<body>

<div id="map"></div>
<canvas id="anim"></canvas>
<div id="label">Loading…</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/* ------------------------------------------------------------
   PARAM PARSING
------------------------------------------------------------ */
const P = new URLSearchParams(location.search);
const API = P.get("api");
const ROUTE = P.get("route");

if (!API) {
  document.body.innerHTML =
    "<h2 style='color:white;padding:20px'>Missing api= parameter</h2>";
  throw new Error("Missing API");
}

/* ------------------------------------------------------------
   CANVAS SETUP
------------------------------------------------------------ */
const canvas = document.getElementById("anim");
const ctx = canvas.getContext("2d");

let W = 0, H = 0;
function resizeCanvas() {
  W = canvas.width  = window.innerWidth * devicePixelRatio;
  H = canvas.height = window.innerHeight * devicePixelRatio;
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

/* ------------------------------------------------------------
   HELPERS
------------------------------------------------------------ */
async function fetchJSON(url) {
  const r = await fetch(url, { cache: "no-store" });
  if (!r.ok) throw new Error("API fetch error " + r.status);
  return r.json();
}

async function loadGPX(url) {
  const xml = await (await fetch(url)).text();
  const dom = new DOMParser().parseFromString(xml, "text/xml");
  const pts = [...dom.getElementsByTagName("trkpt")];
  return pts.map(p => ({
    lat: parseFloat(p.getAttribute("lat")),
    lon: parseFloat(p.getAttribute("lon"))
  }));
}

/* ------------------------------------------------------------
   MAIN
------------------------------------------------------------ */
(async function main() {
  const master = await fetchJSON(API);
  const settings = master.settings;
  const routes = master.routes;

  const route = routes.find(r => r.routeName === ROUTE)
            || routes.find(r => (r.routeName || "").toLowerCase() === ROUTE.toLowerCase());

  if (!route) {
    document.body.innerHTML =
      "<h2 style='color:white;padding:20px'>Route not found: " + ROUTE + "</h2>";
    return;
  }

  document.getElementById("label").textContent =
    route.routeName + " – " + (route.date || "");

  /* ------------------------------------------------------------
     LEAFLET MAP
  ------------------------------------------------------------ */
  const map = L.map("map", { zoomControl: false });
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19
  }).addTo(map);

  const gpx = await loadGPX(route.gpxUrl);

  // Fit map to GPX route
  map.fitBounds(gpx.map(p => [p.lat, p.lon]), { padding: [40, 40] });

  const projected = [];
  function refreshProjection() {
    projected.length = 0;
    for (const p of gpx) {
      projected.push(
        map.latLngToContainerPoint([p.lat, p.lon])
      );
    }
  }
  refreshProjection();
  map.on("move zoom", refreshProjection);

  /* ------------------------------------------------------------
     LOAD SPRITE + START ANIMATION
  ------------------------------------------------------------ */
  const sprite = new Image();
  sprite.crossOrigin = "anonymous";
  sprite.src = settings.travelboost_sprite;

  sprite.onload = () =>
    animate(projected, sprite, settings);
})();
  
/* ------------------------------------------------------------
   ANIMATION ENGINE
------------------------------------------------------------ */
function animate(path, sprite, settings) {

  const fps      = Number(settings.travelboost_sprite_fps)   || 14;
  const frames   = Number(settings.travelboost_sprite_frames)|| 5;
  const size     = Number(settings.travelboost_sprite_size)  || 128;
  const speed    = Number(settings.travelboost_speed)        || 1.5;
  const accent   = settings.travelboost_accent_color || "#ffd700";
  const shadowOn = settings.travelboost_shadow === true || settings.travelboost_shadow === "TRUE";

  // ★★★ Calibrated anchors — makes Santa sit exactly on the line
  const anchorX = size * 0.50;   // horizontal centre
  const anchorY = size * 0.66;   // sleigh rails perfectly on GPX

  let frameIdx = 0;
  let frameTimer = 0;
  let pos = 0;

  const fw = sprite.width / frames;
  const fh = sprite.height;

  function loop() {
    ctx.clearRect(0, 0, W, H);

    if (path.length < 2) return requestAnimationFrame(loop);

    // Advance along route
    pos += speed;
    if (pos >= path.length - 1) pos = path.length - 1;

    const i  = Math.floor(pos);
    const t  = pos - i;

    const a  = path[i];
    const b  = path[i + 1];
    const px = a.x + (b.x - a.x) * t;
    const py = a.y + (b.y - a.y) * t;

    // Determine travel angle
    const angle = Math.atan2(b.y - a.y, b.x - a.x);

    // Draw magical golden trail *behind Santa*
    ctx.save();
    ctx.lineWidth = 6;
    ctx.strokeStyle = accent;
    ctx.lineCap = "round";

    if (shadowOn) {
      ctx.shadowColor = accent;
      ctx.shadowBlur = 20;
    }

    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let j = 1; j <= i; j++)
      ctx.lineTo(path[j].x, path[j].y);
    ctx.lineTo(px, py);
    ctx.stroke();
    ctx.restore();

    // Frame animation
    frameTimer += 1 / 60;
    if (frameTimer >= 1 / fps) {
      frameTimer = 0;
      frameIdx = (frameIdx + 1) % frames;
    }

    // Sprite render WITH rotation + perfect anchor
    ctx.save();
    ctx.translate(px, py);
    ctx.rotate(angle);

    ctx.drawImage(
      sprite,
      fw * frameIdx, 0, fw, fh,   // source frame
      -anchorX, -anchorY,         // calibrated anchor
      size, (fh / fw) * size      // scale
    );
    ctx.restore();

    requestAnimationFrame(loop);
  }

  loop();
}
</script>

</body>
</html>
