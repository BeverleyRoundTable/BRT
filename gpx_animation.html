<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Turbo Santa GPX Animation</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" />

<style>
html,body{margin:0;height:100%;overflow:hidden;background:#0b0d12}
#map{position:absolute;inset:0}
#anim{position:absolute;inset:0;pointer-events:none}

/* ================= LOGO OVERLAY ================= */
#logo-overlay {
  position: fixed;
  z-index: 9999;
  pointer-events: none;
}
#logo-overlay img {
  display: block;
  max-width: 100%;
  height: auto;
  filter: drop-shadow(0 4px 10px rgba(0,0,0,.6));
}
</style>
</head>

<body>
<div id="map"></div>
<canvas id="anim"></canvas>

<div id="logo-overlay" hidden>
  <img id="logo-overlay-img" />
</div>

<script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>

<script>
/* ================= FLAGS ================= */
const PARAMS=new URLSearchParams(location.search);
const IS_RENDER=PARAMS.has("render");
const API=PARAMS.get("api");
const ROUTE=PARAMS.get("route");
window.__GPX_DONE__=false;

// ===== GLOBAL FAIL-SAFE =====
window.addEventListener("error", e => {
  console.error("GPX fatal error", e);
  window.__GPX_DONE__ = true;
});

/* ================= CANVAS ================= */
const canvas=document.getElementById("anim");
const ctx=canvas.getContext("2d");

function resize(){
  if(!map) return;
  const mapCanvas = map.getCanvas();
  const dpr = devicePixelRatio || 1;

  VIEW_W = mapCanvas.clientWidth;
  VIEW_H = mapCanvas.clientHeight;

  canvas.width  = VIEW_W * dpr;
  canvas.height = VIEW_H * dpr;
  canvas.style.width  = VIEW_W + "px";
  canvas.style.height = VIEW_H + "px";

  ctx.setTransform(dpr,0,0,dpr,0,0);
}

let map=null;
let VIEW_W=0, VIEW_H=0;

/* ================= SNOW ================= */
function createSnow(enabled){
  const flakes=[],D=0.00018;
  function add(r=false){
    flakes.push({
      x:Math.random()*VIEW_W,
      y:r?Math.random()*VIEW_H:-20,
      r:Math.random()*2+1,
      vy:Math.random()*1.5+1,
      vx:Math.random()*0.4-0.2,
      d:Math.random()*6.28
    });
  }
  function resizeSnow(){
    const t=Math.floor(VIEW_W*VIEW_H*D);
    while(flakes.length<t) add(true);
    while(flakes.length>t) flakes.pop();
  }
  function update(){
    if(!enabled) return;
    for(const f of flakes){
      f.d+=0.01;
      f.x+=f.vx+Math.sin(f.d)*0.15;
      f.y+=f.vy;
      if(f.y>VIEW_H+30){f.y=-20;f.x=Math.random()*VIEW_W;}
    }
  }
  function draw(){
    if(!enabled) return;
    ctx.save();
    ctx.fillStyle="#fff";
    ctx.shadowColor="rgba(255,255,255,.6)";
    ctx.shadowBlur=4;
    ctx.globalAlpha=.95;
    for(const f of flakes){
      ctx.beginPath();
      ctx.arc(f.x,f.y,f.r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }
  resizeSnow();
  addEventListener("resize",resizeSnow);
  return {update,draw,resize:resizeSnow};
}

/* ================= HELPERS ================= */
const MAP_STYLE={
  version:8,
  sources:{
    "raster":{
      type:"raster",
      tiles:["https://basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}@2x.png"],
      tileSize:256
    }
  },
  layers:[{id:"base",type:"raster",source:"raster"}]
};

const dist=(a,b)=>{
  const R=6371000;
  const dLat=(b.lat-a.lat)*Math.PI/180;
  const dLng=(b.lng-a.lng)*Math.PI/180;
  const s=Math.sin(dLat/2)**2+
    Math.cos(a.lat*Math.PI/180)*Math.cos(b.lat*Math.PI/180)*
    Math.sin(dLng/2)**2;
  return 2*R*Math.asin(Math.sqrt(s));
};
const bearing=(a,b)=>{
  const dLng=(b.lng-a.lng)*Math.PI/180;
  const y=Math.sin(dLng)*Math.cos(b.lat*Math.PI/180);
  const x=Math.cos(a.lat*Math.PI/180)*Math.sin(b.lat*Math.PI/180)-
    Math.sin(a.lat*Math.PI/180)*Math.cos(b.lat*Math.PI/180)*Math.cos(dLng);
  return (Math.atan2(y,x)*180/Math.PI+360)%360;
};
const lerpA=(a,b,t)=>a+(((b-a+540)%360)-180)*t;

function smoothPath(p,it=2){
  if(it<=0||p.length<3) return p;
  const o=[p[0]];
  for(let i=0;i<p.length-1;i++){
    const a=p[i],b=p[i+1];
    o.push({lat:.75*a.lat+.25*b.lat,lng:.75*a.lng+.25*b.lng});
    o.push({lat:.25*a.lat+.75*b.lat,lng:.25*a.lng+.75*b.lng});
  }
  o.push(p.at(-1));
  return smoothPath(o,it-1);
}

/* ================= LOGO OVERLAY ================= */
function applyLogoOverlay(s){
  if(String(s.logo_overlay_enabled).toLowerCase()!=="true") return;
  if(!s.logo_overlay_url) return;

  const w=document.getElementById("logo-overlay");
  const i=document.getElementById("logo-overlay-img");
  i.src=s.logo_overlay_url;
  i.style.width=(+s.logo_overlay_size||64)+"px";

  w.style.top=w.style.right=w.style.bottom=w.style.left="auto";
  w.style.margin="16px";
  const p=(s.logo_overlay_position||"bottom-right").toLowerCase();
  if(p.includes("top")) w.style.top="0";
  if(p.includes("bottom")) w.style.bottom="0";
  if(p.includes("left")) w.style.left="0";
  if(p.includes("right")) w.style.right="0";
  w.hidden=false;
}

/* ================= LOAD ================= */
(async()=>{
  const master=await fetch(API,{cache:"no-store"}).then(r=>r.json());
  const s=master.settings||{};
  applyLogoOverlay(s);

  const r=master.routes.find(x=>x.routeName?.toLowerCase()===(ROUTE||"").toLowerCase());

  const rawPts=await fetch(r.gpxUrl).then(r=>r.text()).then(x=>
    [...new DOMParser().parseFromString(x,"text/xml").getElementsByTagName("trkpt")]
      .map(p=>({lat:+p.getAttribute("lat"),lng:+p.getAttribute("lon")}))
  );

  const pts=smoothPath(rawPts,2);

  const sprite=await new Promise(res=>{
    const i=new Image(); i.onload=()=>res(i); i.src=s.travelboast_sprite;
  });

  run(rawPts,pts,sprite,s);
})();

/* ================= ANIMATION ================= */
function run(rawPts,pts,sprite,s){
map=new maplibregl.Map({
  container:"map",
  style:MAP_STYLE,
  center:[pts[0].lng,pts[0].lat],
  zoom:+s.default_map_zoom||16
});

const FOLLOW_ZOOM = IS_RENDER ? 18.8 : 17;
const FOLLOW_PITCH = IS_RENDER ? 22 : 40;

const SPRITE_FPS=+s.travelboast_sprite_fps||12;
const FRAMES=+s.travelboast_sprite_frames||5;
const SPRITE_SIZE=+s.travelboast_sprite_size||64;

let spriteTimer=0,spriteFrame=0;

const snow=createSnow(String(s.travelboast_particle_effects).toLowerCase()==="snow");

const cum=[0];
for(let i=1;i<pts.length;i++) cum[i]=cum[i-1]+dist(pts[i-1],pts[i]);
const total=cum.at(-1);

// âœ… END OVERVIEW SUPPORT
const bounds=new maplibregl.LngLatBounds();
for(const p of pts) bounds.extend([p.lng,p.lat]);

let finished=false;
let overviewAt=null;

let m=0,last=null,camB=0,sprB=0;

map.on("load",()=>{
  resize();
  snow.resize();
  map.on("resize",resize);

  map.addSource("route-progress",{type:"geojson",data:{type:"Feature",geometry:{type:"LineString",coordinates:[]}}});
  map.addLayer({
    id:"route-progress",
    type:"line",
    source:"route-progress",
    paint:{ "line-color":s.primary_color||"#d31c1c","line-width":6 }
  });

  requestAnimationFrame(step);
});

function step(ts){
  let dt=last?(ts-last)/1000:0; last=ts;
  ctx.clearRect(0,0,VIEW_W,VIEW_H);
  snow.update(); snow.draw();

  m+=((+s.travelboast_speed||.1)*18)*dt;

  if(!finished && m>=total){
    finished=true;

    map.stop();
    map.fitBounds(bounds,{
      padding:120,
      pitch:0,
      bearing:0,
      duration:3500,
      maxZoom:14
    });

    overviewAt=performance.now();
  }

  if(finished){
    if(overviewAt && performance.now()-overviewAt>8500){
      window.__GPX_DONE__=true;
      return;
    }
    requestAnimationFrame(step);
    return;
  }

  let i=cum.findIndex(v=>v>=m); i=Math.max(1,i);
  const t=(m-cum[i-1])/(cum[i]-cum[i-1]||1);
  const a=pts[i-1],b=pts[i];
  const pos={lat:a.lat+(b.lat-a.lat)*t,lng:a.lng+(b.lng-a.lng)*t};

  map.getSource("route-progress").setData({
    type:"Feature",
    geometry:{type:"LineString",coordinates:[...pts.slice(0,i).map(p=>[p.lng,p.lat]),[pos.lng,pos.lat]]}
  });

  spriteTimer+=dt;
  if(spriteTimer>=1/SPRITE_FPS){spriteTimer-=1/SPRITE_FPS;spriteFrame=(spriteFrame+1)%FRAMES;}

  sprB=lerpA(sprB,bearing(a,b),.25);
  camB=lerpA(camB,sprB,.15);

  map.jumpTo({center:[pos.lng,pos.lat],zoom:FOLLOW_ZOOM,bearing:camB,pitch:FOLLOW_PITCH});

  const p=map.project([pos.lng,pos.lat]);
  const fw=sprite.width/FRAMES;

  ctx.save();
  ctx.translate(p.x,p.y-SPRITE_SIZE*.32);
  ctx.rotate((((sprB-camB+540)%360)-180)*.4*Math.PI/180);
  ctx.drawImage(sprite,spriteFrame*fw,0,fw,sprite.height,-SPRITE_SIZE/2,-SPRITE_SIZE/2,SPRITE_SIZE,SPRITE_SIZE);
  ctx.restore();

  requestAnimationFrame(step);
}
}
</script>
</body>
</html>
