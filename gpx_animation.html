<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Santa Sleigh – GPX Animator (TravelBoost)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

<style>
  html, body {
    margin: 0; padding: 0;
    height: 100%;
    overflow: hidden;
    background: #000;
  }

  #map { position:absolute; inset:0; z-index:1; }
  #canvas { position:absolute; inset:0; z-index:20; pointer-events:none; }
  #label {
    position:absolute;
    bottom:12px; left:50%;
    transform:translateX(-50%);
    z-index:30;
    color:white;
    font-size:1rem;
    font-family:system-ui;
    text-shadow:0 0 8px black;
  }
</style>
</head>
<body>

<div id="map"></div>
<canvas id="canvas"></canvas>
<div id="label">Loading…</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
// ---------------------------------------------------------
// URL PARAMS
// ---------------------------------------------------------
const P = new URLSearchParams(location.search);
const API   = P.get("api");
const ROUTE = P.get("route");

if (!API) {
  document.body.innerHTML = "<h2 style='padding:20px;color:white'>Missing api= parameter</h2>";
  throw new Error("Missing API");
}

// ---------------------------------------------------------
// CANVAS SETUP
// ---------------------------------------------------------
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let W=0, H=0;

function resizeCanvas() {
  W = canvas.width  = window.innerWidth  * devicePixelRatio;
  H = canvas.height = window.innerHeight * devicePixelRatio;
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// ---------------------------------------------------------
// HELPERS
// ---------------------------------------------------------
async function fetchJSON(url) {
  const r = await fetch(url, {cache:"no-store"});
  return r.json();
}

async function loadGPX(url) {
  const xml = await (await fetch(url)).text();
  const dom = new DOMParser().parseFromString(xml, "text/xml");
  return [...dom.getElementsByTagName("trkpt")].map(pt => ({
    lat: parseFloat(pt.getAttribute("lat")),
    lon: parseFloat(pt.getAttribute("lon"))
  }));
}

function animateSprite(path, sprite, settings) {
  const frames = Number(settings.travelboost_sprite_frames || 5);
  const fps = Number(settings.travelboost_sprite_fps || 14);
  const size = Number(settings.travelboost_sprite_size || 128);
  const speed = Number(settings.travelboost_speed || 1);
  const accent = settings.travelboost_accent_color || "#ffd700";

  let fIndex = 0;
  let fTimer = 0;
  let t = 0;

  function loop() {
    ctx.clearRect(0,0,W,H);

    // advance animation along route
    t += speed;
    if (t >= path.length - 1) t = 0;

    const i = Math.floor(t);
    const frac = t - i;
    const A = path[i];
    const B = path[i+1];
    const x = A.x + (B.x - A.x)*frac;
    const y = A.y + (B.y - A.y)*frac;

    // ----- DRAW PARTIAL TRAIL -----
    ctx.save();
    ctx.lineWidth = 6;
    ctx.strokeStyle = accent;
    ctx.shadowColor = accent;
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let k = 1; k <= i; k++) ctx.lineTo(path[k].x, path[k].y);
    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.restore();

    // ----- ANIMATE SPRITE -----
    fTimer += 1/60;
    if (fTimer >= 1/fps) {
      fTimer = 0;
      fIndex = (fIndex + 1) % frames;
    }

    const frameW = sprite.width / frames;
    const frameH = sprite.height;

    // CORRECTED — centre sprite exactly on track point
    ctx.drawImage(
      sprite,
      frameW * fIndex, 0, frameW, frameH,
      x - size/2,
      y - size/2,     // <---- FIXED POSITIONING (no more ahead of line!)
      size,
      (frameH/frameW)*size
    );

    requestAnimationFrame(loop);
  }

  loop();
}

function project(path) {
  let minLat=Infinity,maxLat=-Infinity,minLon=Infinity,maxLon=-Infinity;

  path.forEach(p => {
    minLat = Math.min(minLat, p.lat);
    maxLat = Math.max(maxLat, p.lat);
    minLon = Math.min(minLon, p.lon);
    maxLon = Math.max(maxLon, p.lon);
  });

  const vw = W/devicePixelRatio;
  const vh = H/devicePixelRatio;
  const pad = 50;

  const spanLat = maxLat - minLat;
  const spanLon = maxLon - minLon;

  const sx = (vw - pad*2)/spanLon;
  const sy = (vh - pad*2)/spanLat;
  const scale = Math.min(sx, sy);

  const ox = (vw - scale*spanLon)/2;
  const oy = (vh - scale*spanLat)/2;

  return path.map(p => ({
    x: ox + (p.lon - minLon)*scale,
    y: oy + (maxLat - p.lat)*scale
  }));
}

// ---------------------------------------------------------
// MAIN FLOW
// ---------------------------------------------------------
(async function start() {

  const master = await fetchJSON(API);
  const settings = master.settings || {};

  const route = master.routes.find(r => r.routeName === ROUTE)
             || master.routes.find(r => (r.routeName || "").toLowerCase() === ROUTE.toLowerCase());

  if (!route) {
    document.getElementById("label").textContent = "Route not found";
    return;
  }

  document.getElementById("label").textContent = `${route.routeName} – ${route.date || ""}`;

  // Setup map
  const map = L.map("map", { zoomControl:false });
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);

  const gpx = await loadGPX(route.gpxUrl);
  L.polyline(gpx, {color:"#ffffff55", weight:3}).addTo(map);
  map.fitBounds(gpx.map(p => [p.lat, p.lon]), {padding:[40,40]});

  // Convert to 2D canvas coordinates
  const path2D = project(gpx);

  // Load sprite sheet
  const sprite = new Image();
  sprite.crossOrigin = "anonymous";
  sprite.src = settings.travelboost_sprite;

  sprite.onload = () => animateSprite(path2D, sprite, settings);

})();
</script>

</body>
</html>
