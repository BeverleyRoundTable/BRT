<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Santa GPX TravelBoast Style</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: #f3f3f3; overflow: hidden;
    font-family: system-ui, -apple-system, BlinkMacSystemFont,
                 "Segoe UI", Roboto, sans-serif;
  }

  #map {
    position: absolute;
    inset: 0;
    z-index: 1;
  }

  #anim {
    position: absolute;
    inset: 0;
    z-index: 10;
    pointer-events: none;
  }

  /* Floating pill at bottom */
  #ui-layer {
    position: absolute;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 20;
    pointer-events: none;
    text-align: center;
  }

  .pill {
    background: rgba(0, 0, 0, 0.7);
    color: #fff;
    padding: 10px 20px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.2);
    box-shadow: 0 6px 16px rgba(0,0,0,0.45);
    backdrop-filter: blur(6px);
    display: inline-block;
    max-width: 90vw;
  }

  #route-name {
    margin: 0;
    font-size: 1rem;
    font-weight: 600;
  }
  #route-date {
    margin: 2px 0 0 0;
    font-size: 0.8rem;
    opacity: 0.8;
  }
</style>
</head>
<body>

<div id="map"></div>
<canvas id="anim"></canvas>

<div id="ui-layer">
  <div class="pill">
    <h1 id="route-name">Loading route…</h1>
    <p id="route-date"></p>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/* ------------------------------------------------------------
   PARAMS
------------------------------------------------------------ */
const P = new URLSearchParams(location.search);
const API   = P.get("api");
const ROUTE = P.get("route");

if (!API) {
  document.body.innerHTML =
    "<h2 style='padding:20px;font-family:sans-serif'>❌ Missing api= parameter</h2>";
  throw new Error("Missing api");
}

/* ------------------------------------------------------------
   CANVAS SETUP (DPR AWARE)
------------------------------------------------------------ */
const canvas = document.getElementById("anim");
const ctx = canvas.getContext("2d");

function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width  = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/* ------------------------------------------------------------
   LEAFLET MAP (LIGHT OSM)
------------------------------------------------------------ */
const map = L.map("map", {
  zoomControl: false,
  attributionControl: true
});

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  maxZoom: 20
}).addTo(map);

/* ------------------------------------------------------------
   HELPERS
------------------------------------------------------------ */
async function fetchJSON(url) {
  const r = await fetch(url, { cache: "no-store" });
  if (!r.ok) throw new Error("API fetch error " + r.status);
  return r.json();
}

async function loadGPX(url) {
  const xml = await (await fetch(url, { cache: "no-store" })).text();
  const dom = new DOMParser().parseFromString(xml, "text/xml");
  const pts = [...dom.getElementsByTagName("trkpt")];
  return pts.map(p => ({
    lat: parseFloat(p.getAttribute("lat")),
    lng: parseFloat(p.getAttribute("lon") || p.getAttribute("lng"))
  }));
}

// Simple Chaikin-style smoothing to make the line nicer
function smoothPath(points, iterations = 2) {
  if (iterations <= 0 || points.length < 3) return points;
  let out = [points[0]];
  for (let i = 0; i < points.length - 1; i++) {
    const p0 = points[i];
    const p1 = points[i + 1];
    out.push({
      lat: 0.75 * p0.lat + 0.25 * p1.lat,
      lng: 0.75 * p0.lng + 0.25 * p1.lng
    });
    out.push({
      lat: 0.25 * p0.lat + 0.75 * p1.lat,
      lng: 0.25 * p0.lng + 0.75 * p1.lng
    });
  }
  out.push(points[points.length - 1]);
  return smoothPath(out, iterations - 1);
}

function getAngle(p1, p2) {
  return Math.atan2(p2.y - p1.y, p2.x - p1.x);
}
function lerpAngle(a, b, t) {
  const diff = (b - a + Math.PI) % (2 * Math.PI) - Math.PI;
  return a + diff * t;
}

/* ------------------------------------------------------------
   SPARKLES
------------------------------------------------------------ */
const SPARKLE_RGB = "255, 215, 0"; // gold
const SPARKLES_PER_FRAME = 3;
const particles = [];

class Particle {
  constructor(x, y) {
    this.x = x + (Math.random() - 0.5) * 10;
    this.y = y + (Math.random() - 0.5) * 10;
    this.vx = (Math.random() - 0.5) * 0.5;
    this.vy = (Math.random() - 0.5) * 0.5;
    this.life = 1;
    this.decay = 0.02 + Math.random() * 0.03;
    this.size = 1 + Math.random() * 3;
  }
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.life -= this.decay;
  }
  draw(ctx) {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${SPARKLE_RGB}, ${this.life})`;
    ctx.fill();
  }
}

/* ------------------------------------------------------------
   MAIN
------------------------------------------------------------ */
(async function main() {
  try {
    const master   = await fetchJSON(API);
    const settings = master.settings || {};
    const routes   = master.routes  || [];

    const route = routes.find(r =>
      (r.routeName || "").toLowerCase() === (ROUTE || "").toLowerCase()
    ) || routes.find(r => r.routeName === ROUTE);

    if (!route) {
      document.querySelector(".pill").innerHTML =
        "<span style='color:#ffb3b3'>Route not found: " +
        (ROUTE || "(none)") + "</span>";
      return;
    }

    document.getElementById("route-name").textContent = route.routeName || "";
    document.getElementById("route-date").textContent = route.date || "";

    // Load GPX & smooth
    let rawPoints = await loadGPX(route.gpxUrl);
    if (rawPoints.length < 2) throw new Error("GPX route has too few points");
    const pathLatLngs = smoothPath(rawPoints, 3);

    // Fit to route, then zoom in a bit for "close" feel
    const bounds = L.latLngBounds(pathLatLngs.map(p => [p.lat, p.lng]));
    map.fitBounds(bounds, { padding: [40, 40] });
    setTimeout(() => map.setZoom(map.getZoom() + 2), 150);

    // Load sprite
    const sprite = new Image();
    sprite.crossOrigin = "anonymous";
    sprite.src = settings.travelboost_sprite; // your 5x1 strip
    await new Promise(res => sprite.onload = res);

    startAnimation(pathLatLngs, sprite, settings);

  } catch (err) {
    console.error(err);
    document.querySelector(".pill").innerHTML =
      "<span style='color:#ffb3b3'>" +
      (err.message || "Animation error") + "</span>";
  }
})();

/* ------------------------------------------------------------
   ANIMATION LOOP
------------------------------------------------------------ */
function startAnimation(latLngs, sprite, settings) {
  let lastTime = 0;
  let dist = 0;
  let currentAngle = 0;

  const fps      = Number(settings.travelboost_sprite_fps)    || 12;
  const frames   = Number(settings.travelboost_sprite_frames) || 5;
  const renderSz = Number(settings.travelboost_sprite_size)   || 120;
  const speedCfg = Number(settings.travelboost_speed)         || 1.5;

  // tweakable: magic acceleration factor
  const speedFactor = 0.00007;
  const speed = speedCfg * speedFactor;

  const accent = settings.travelboost_accent_color || "#ffd700";

  const spriteW = sprite.width / frames;
  const spriteH = sprite.height;

  function frame(ts) {
    if (!lastTime) lastTime = ts;
    const dt = ts - lastTime;
    lastTime = ts;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Advance along route
    dist += speed * dt;
    if (dist >= latLngs.length - 1) dist = latLngs.length - 1;

    const idx = Math.floor(dist);
    const t   = dist - idx;
    const p1  = latLngs[idx];
    const p2  = latLngs[Math.min(idx + 1, latLngs.length - 1)];

    // Interpolated lat/lng
    const curLat = p1.lat + (p2.lat - p1.lat) * t;
    const curLng = p1.lng + (p2.lng - p1.lng) * t;
    const curLL  = { lat: curLat, lng: curLng };

    // Keep camera close to Santa
    map.panTo([curLat, curLng], { animate: false });

    // Project to pixels
    const curPix = map.latLngToContainerPoint(curLL);
    const p1Pix  = map.latLngToContainerPoint(p1);
    const p2Pix  = map.latLngToContainerPoint(p2);

    // Draw trail only behind Santa (no ahead)
    ctx.save();
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = accent;
    ctx.lineWidth = 6;
    ctx.shadowColor = accent;
    ctx.shadowBlur = 18;
    ctx.beginPath();

    // Start at first point
    const startPix = map.latLngToContainerPoint(latLngs[0]);
    ctx.moveTo(startPix.x, startPix.y);
    for (let i = 1; i <= idx; i++) {
      const lp = map.latLngToContainerPoint(latLngs[i]);
      ctx.lineTo(lp.x, lp.y);
    }
    ctx.lineTo(curPix.x, curPix.y);
    ctx.stroke();
    ctx.restore();

    // Sparkles at Santa's feet
    if (dist < latLngs.length - 1) {
      for (let i = 0; i < SPARKLES_PER_FRAME; i++) {
        particles.push(new Particle(curPix.x, curPix.y));
      }
    }
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.update();
      p.draw(ctx);
      if (p.life <= 0) particles.splice(i, 1);
    }

    // Sprite orientation
    const targetAngle = getAngle(p1Pix, p2Pix);
    const segLenSq = (p2Pix.x - p1Pix.x) ** 2 + (p2Pix.y - p1Pix.y) ** 2;
    if (segLenSq > 1) {
      currentAngle = lerpAngle(currentAngle, targetAngle, 0.18);
    }

    // Current animation frame
    const frameIndex = Math.floor((ts / 1000) * fps) % frames;

    // Draw Santa (sprite faces NORTH in source → add +90°)
    ctx.save();
    ctx.translate(curPix.x, curPix.y);
    ctx.rotate(currentAngle + Math.PI / 2);

    ctx.drawImage(
      sprite,
      frameIndex * spriteW, 0, spriteW, spriteH,   // source frame
      -renderSz / 2, -renderSz / 2,                // centred
      renderSz, renderSz                           // on-screen size
    );

    ctx.restore();

    if (dist < latLngs.length - 1) {
      requestAnimationFrame(frame);
    }
  }

  requestAnimationFrame(frame);
}
</script>

</body>
</html>
