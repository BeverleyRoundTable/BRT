<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Santa Sleigh Tracker</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.7.0/gpx.min.js"></script>
<script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
  
<style>
html,body{
  margin:0;
  padding:0;
  height:100%;
  background:#001;
  color:#fff;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;
  overflow:hidden;
}

:root{
  --ui-bottom-safe: 72px;
  --donate-bottom: calc(var(--ui-bottom-safe) + 92px);
  --info-bottom: var(--ui-bottom-safe);
}

@supports(padding: env(safe-area-inset-bottom)){
  :root{
    --ui-bottom-safe: calc(88px + env(safe-area-inset-bottom));
    --donate-bottom: calc(var(--ui-bottom-safe) + 92px);
    --info-bottom: var(--ui-bottom-safe);
  }
}

#map{
  position:absolute;
  inset:0;
}

.status-popup{
  position:absolute;
  top:20px;
  left:50%;
  transform:translateX(-50%);
  background:rgba(24,24,24,.95);
  padding:14px 20px;
  font-size:1.05em;
  font-weight:800;
  border-radius:16px;
  max-width:90%;
  box-shadow:0 4px 24px #0006;
  z-index:4000;
  text-align:center;
}

.donate-box{
  position:fixed;
  bottom: var(--donate-bottom);
  left:50%;
  transform:translateX(-50%);
  width:70%;
  max-width:420px;
  z-index:2000;
}
.donate-btn{
  background:#d31c1c;
  color:#fff;
  padding:14px 0;
  display:block;
  text-align:center;
  border-radius:16px;
  font-weight:900;
  text-decoration:none;
  box-shadow:0 4px 16px rgba(0,0,0,.4);
}

.info-popup{
  position:fixed;
  bottom: var(--info-bottom);
  left:50%;
  transform:translateX(-50%);
  background:rgba(20,20,20,.94);
  padding:10px 14px;
  border-radius:14px;
  display:flex;
  align-items:center;
  gap:12px;
  font-size:.85em;
  font-weight:800;
  z-index:2000;
  max-width:calc(100vw - 32px);
  box-sizing:border-box;
}

.status-dot{
  width:12px;
  aspect-ratio:1 / 1;
  border-radius:50%;
  flex-shrink:0;
  display:none;
}
.dot-moving{
  background:#2cff4e;
  animation:pulse 1.4s infinite;
}
.dot-stopped{
  background:#ff3b3b;
}
@keyframes pulse{
  0%{ box-shadow:0 0 0 0 rgba(44,255,78,.6); }
  70%{ box-shadow:0 0 0 10px rgba(44,255,78,0); }
  100%{ box-shadow:0 0 0 0 rgba(44,255,78,0); }
}

.btn{
  background:#0b1220;
  color:#fff;
  border:1px solid #ffffff26;
  border-radius:10px;
  padding:7px 12px;
  cursor:pointer;
  font-weight:800;
}

.logo-overlay{
  position:relative;
  width:48px;
  max-width:18vw;
  pointer-events:none;
  opacity:.9;
  filter:drop-shadow(0 2px 6px rgba(0,0,0,.5));
}

#loadingCover{
  position:fixed;
  inset:0;
  background:#000;
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:6000;
}
#loadingSpinner{
  width:52px;
  height:52px;
  border-radius:50%;
  border:4px solid rgba(255,255,255,.25);
  border-top-color:#ffd700;
  animation:spin .9s linear infinite;
}
@keyframes spin{to{transform:rotate(360deg)}}

@media (max-height: 700px){
  :root{
    --ui-bottom-safe: calc(64px + env(safe-area-inset-bottom));
  }
  .donate-box{
    width:85%;
    max-width:360px;
  }
  .info-popup{
    font-size:.8em;
    padding:8px 12px;
  }
  .status-popup{
    font-size:.95em;
    padding:12px 16px;
  }
}

body.dim-ui .donate-box,
body.dim-ui .info-popup,
body.dim-ui .status-popup{
  opacity: 0.45;
  filter: saturate(0.85);
  transition: opacity 600ms ease, filter 600ms ease;
}

body.dim-ui .donate-box:hover,
body.dim-ui .info-popup:hover,
body.dim-ui .status-popup:hover{
  opacity: 0.75;
}

body.dim-ui * {
  transition: opacity 600ms ease, filter 600ms ease;
}

body.dim-ui #map {
  filter: brightness(0.85);
}

body.night-mode #map {
  filter: brightness(0.75) saturate(0.9) hue-rotate(-8deg);
}

body.night-mode .status-popup {
  background: rgba(12,16,28,0.95);
}

#snow {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 1500;
  opacity: 0;
  transition: opacity 800ms ease;
}

body.snowing #snow {
  opacity: 1;
  filter: drop-shadow(0 0 4px white);
}

body::after {
  content: '';
  position: fixed;
  inset: 0;
  background: radial-gradient(circle, transparent 40%, rgba(0,0,0,0.6) 100%);
  pointer-events: none;
  opacity: 0;
  transition: opacity 1.5s ease;
  z-index: 1400;
}

body.snowing::after {
  opacity: 1;
}
</style>
</head>

<body>

<div id="loadingCover"><div id="loadingSpinner"></div></div>

<div class="status-popup" id="statusBox">
  üîç Searching for Santa‚Ä¶
</div>

<div class="donate-box" id="donateBox">
  <a id="donateLink" class="donate-btn" target="_blank">
    üéÅ DONATE & SUPPORT US
  </a>
</div>

<div class="info-popup">
  <div id="statusDot" class="status-dot"></div>
  <button class="btn" id="followBtn">Follow: ON</button>
  <button class="btn" id="recenterBtn">Re-centre</button>
  <button class="btn" id="notifyBtn">üîî Notify Me</button>
</div>

<div id="map"></div>
<canvas id="snow"></canvas>

<script>
(function() {
  'use strict';

  /* ===================================================
     CONSTANTS & CONFIGURATION
  =================================================== */
  
  const CONFIG = {
    // Movement detection (25 seconds window, 8 meter threshold for slow sleigh)
    MOTION_WINDOW_MS: 25 * 1000,
    MOVE_THRESHOLD_METERS: 8,
    
    // Route snapping (60 meter tolerance before showing off-route)
    OFF_ROUTE_THRESHOLD_METERS: 60,
    GPX_SEARCH_WINDOW: 50, // Points to search around last position
    
    // ETA calculation (requires 3 fixes over 15 seconds minimum)
    MIN_FIXES_FOR_ETA: 3,
    MIN_ETA_WINDOW_MS: 15 * 1000,
    
    // Update intervals
    REFRESH_MS: 3000,
    STALE_TIMEOUT_MS: 5 * 60 * 1000,
    
    // Animation
    MARKER_ANIMATION_MS: 900,
    
    // Snow performance
    SNOW_BASE_COUNT_DESKTOP: 40, // Reduced from 60
    SNOW_BASE_COUNT_MOBILE: 20,  // Reduced from 30
    SNOW_MULTIPLIERS: [0, 1, 2, 3.5], // Level 0-3, reduced max from 5
    
    // Defaults
    LAPLAND_COORDS: [66.5436, 25.8473],
    
    // Fallback icons
    FALLBACK_ICONS: {
      live: "https://i.ibb.co/Qj3vDbSR/Santa-Marker-11.png",
      start: "https://i.ibb.co/PzDYmwzZ/Santa-Marker-4.png",
      end: "https://i.ibb.co/39WF0kBd/Santa-Marker-5.png"
    }
  };

  /* ===================================================
     STATE MANAGEMENT
  =================================================== */
  
  const state = {
    // Map objects
    map: null,
    marker: null,
    notifyMarker: null,
    gpxLayer: null,
    
    // Tracking state
    follow: true,
    firstFix: true,
    lastFix: null,
    lastGoodFix: null,
    staleSince: null,
    
    // GPS fixes with cached distances
    recentFixes: [], // [{lat, lng, ts, cumulativeDist}]
    
    // Animation state
    animCurrent: null,
    animTarget: null,
    animStart: 0,
    animRaf: null,
    
    // GPX route
    gpxRoute: null, // [{lat, lng, dist}]
    gpxTotalDistance: 0,
    gpxLoaded: false,
    lastSnapIndex: 0,
    
    // Notification state
    awaitingPin: false,
    pinPreview: null,
    browserNotified: false,
    
    // Snow state
    snowActive: false,
    currentSnowLevel: 0,
    snowflakes: [],
    
    // API
    apiUrl: null,
    firebaseBaseUrl: null,
    
    // Performance monitoring
    isMobile: false,
    isTabVisible: true,
    batteryLevel: 1,
    
    // Cleanup tracking
    cleanupFunctions: []
  };

  /* ===================================================
     UTILITY FUNCTIONS
  =================================================== */
  
  /**
   * Validate GPS coordinates
   */
  function isValidCoordinate(lat, lng) {
    return typeof lat === "number" && 
           !isNaN(lat) && 
           typeof lng === "number" && 
           !isNaN(lng) &&
           lat >= -90 && lat <= 90 &&
           lng >= -180 && lng <= 180;
  }

  /**
   * Calculate distance between two points using Haversine formula
   * @returns {number} Distance in meters
   */
  function haversineMeters(a, b) {
    const R = 6371000; // Earth radius in meters
    const dLat = (b.lat - a.lat) * Math.PI / 180;
    const dLng = (b.lng - a.lng) * Math.PI / 180;

    const sin = 
      Math.sin(dLat / 2) ** 2 +
      Math.cos(a.lat * Math.PI / 180) *
      Math.cos(b.lat * Math.PI / 180) *
      Math.sin(dLng / 2) ** 2;

    return 2 * R * Math.asin(Math.sqrt(sin));
  }

  /**
   * Linear interpolation
   */
  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  /**
   * Ease-out cubic function for smooth animation
   */
  function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
  }

  /**
   * Fetch JSON with error handling
   */
  async function loadJSON(url) {
    const response = await fetch(url, { cache: "no-store" });
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    return response.json();
  }

  /**
   * Check if current time is after sunset at given location
   */
  function isAfterSunset(lat, lng) {
    const now = new Date();
    const sunset = SunCalc.getTimes(now, lat, lng).sunset;
    return now > sunset;
  }

  /**
   * Detect if device is mobile
   */
  function detectMobile() {
    return window.innerWidth < 600 || 
           /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  }

  /* ===================================================
     GPS FIX MANAGEMENT (with cached distances)
  =================================================== */
  
  /**
   * Add a new GPS fix with cumulative distance calculation
   */
  function addGpsFix(lat, lng, ts) {
    const fix = { lat, lng, ts };
    
    // Calculate cumulative distance
    if (state.recentFixes.length > 0) {
      const prev = state.recentFixes[state.recentFixes.length - 1];
      const dist = haversineMeters(prev, fix);
      fix.cumulativeDist = prev.cumulativeDist + dist;
    } else {
      fix.cumulativeDist = 0;
    }
    
    state.recentFixes.push(fix);
    
    // Trim old fixes outside motion window
    const cutoff = ts - CONFIG.MOTION_WINDOW_MS;
    while (state.recentFixes.length > 0 && state.recentFixes[0].ts < cutoff) {
      state.recentFixes.shift();
    }
  }

  /**
   * Check if sleigh is moving (uses cached distances)
   */
  function isSleighMoving() {
    if (state.recentFixes.length < 2) return false;
    
    const first = state.recentFixes[0];
    const last = state.recentFixes[state.recentFixes.length - 1];
    
    const totalDistance = last.cumulativeDist - first.cumulativeDist;
    return totalDistance >= CONFIG.MOVE_THRESHOLD_METERS;
  }

  /**
   * Calculate stable speed in meters per second
   */
  function calculateStableSpeed() {
    if (state.recentFixes.length < CONFIG.MIN_FIXES_FOR_ETA) return null;

    const first = state.recentFixes[0];
    const last = state.recentFixes[state.recentFixes.length - 1];

    const elapsed = last.ts - first.ts;
    if (elapsed < CONFIG.MIN_ETA_WINDOW_MS) return null;

    const dist = last.cumulativeDist - first.cumulativeDist;
    const speed = dist / (elapsed / 1000);

    // Clamp to realistic sleigh bounds (0.3 - 6 m/s)
    return Math.min(Math.max(speed, 0.3), 6);
  }

  /* ===================================================
     GPX ROUTE HANDLING (optimized search)
  =================================================== */
  
  /**
   * Load and parse GPX route
   */
  async function loadGpxRoute(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`GPX fetch failed: ${res.status}`);

    const text = await res.text();
    const xml = new DOMParser().parseFromString(text, "text/xml");
    const pts = [...xml.getElementsByTagName("trkpt")];

    if (pts.length < 2) throw new Error("GPX route too short");

    let dist = 0;
    let route = [];

    for (let i = 0; i < pts.length; i++) {
      const lat = parseFloat(pts[i].getAttribute("lat"));
      const lng = parseFloat(pts[i].getAttribute("lon"));

      if (i > 0) {
        dist += haversineMeters(route[i - 1], { lat, lng });
      }

      route.push({ lat, lng, dist });
    }

    state.gpxRoute = route;
    state.gpxTotalDistance = dist;
    state.gpxLoaded = true;
    state.lastSnapIndex = 0;
    
    console.log(`GPX loaded: ${route.length} points, ${dist.toFixed(0)}m total`);
  }

  /**
   * Snap position to GPX route (optimized bidirectional search)
   */
  function snapToGpxIndex(pos) {
    if (!state.gpxRoute) return null;

    const route = state.gpxRoute;
    let best = state.lastSnapIndex;
    let bestDist = haversineMeters(pos, route[best]);

    // Search window around last known position
    const windowSize = CONFIG.GPX_SEARCH_WINDOW;
    const start = Math.max(0, state.lastSnapIndex - windowSize);
    const end = Math.min(route.length, state.lastSnapIndex + windowSize);

    for (let i = start; i < end; i++) {
      const d = haversineMeters(pos, route[i]);
      if (d < bestDist) {
        bestDist = d;
        best = i;
      }
    }

    // If still far away, do full search (rare case)
    if (bestDist > CONFIG.OFF_ROUTE_THRESHOLD_METERS * 2) {
      for (let i = 0; i < route.length; i++) {
        const d = haversineMeters(pos, route[i]);
        if (d < bestDist) {
          bestDist = d;
          best = i;
        }
      }
    }

    state.lastSnapIndex = best;

    return {
      point: route[best],
      distance: bestDist,
      index: best
    };
  }

  /**
   * Get visual position (snapped to route if close enough)
   */
  function getVisualLatLng(rawPos) {
    if (!state.gpxLoaded) return rawPos;

    const snap = snapToGpxIndex(rawPos);

    if (snap && snap.distance <= CONFIG.OFF_ROUTE_THRESHOLD_METERS) {
      return snap.point;
    }

    return rawPos;
  }

  /* ===================================================
     MARKER ANIMATION (optimized)
  =================================================== */
  
  /**
   * Animate marker to target position with easing
   */
  function animateMarkerTo(targetLL) {
    if (!state.marker) return;

    // First position - no animation
    if (!state.animCurrent) {
      state.marker.setLatLng(targetLL);
      state.animCurrent = targetLL;
      return;
    }

    // Cancel any in-flight animation
    if (state.animRaf) {
      cancelAnimationFrame(state.animRaf);
      state.animRaf = null;
    }

    state.animTarget = targetLL;
    state.animStart = performance.now();

    const startLL = state.marker.getLatLng();
    const startLat = startLL.lat;
    const startLng = startLL.lng;
    const endLat = targetLL.lat;
    const endLng = targetLL.lng;

    function step(now) {
      const elapsed = now - state.animStart;
      const t = Math.min(1, elapsed / CONFIG.MARKER_ANIMATION_MS);
      const e = easeOutCubic(t);

      const lat = lerp(startLat, endLat, e);
      const lng = lerp(startLng, endLng, e);

      const ll = L.latLng(lat, lng);
      state.marker.setLatLng(ll);
      state.animCurrent = ll;

      // Smooth follow
      if (state.follow && !state.firstFix) {
        state.map.panTo(ll, { animate: true, duration: 0.6 });
      }

      if (t < 1) {
        state.animRaf = requestAnimationFrame(step);
      } else {
        state.animRaf = null;
      }
    }

    state.animRaf = requestAnimationFrame(step);
  }

  /* ===================================================
     SNOW EFFECTS (battery-optimized)
  =================================================== */
  
  const snowCanvas = document.getElementById("snow");
  const snowCtx = snowCanvas.getContext("2d");

  function resizeSnow() {
    snowCanvas.width = window.innerWidth;
    snowCanvas.height = window.innerHeight;
  }

  /**
   * Create snowflakes based on intensity level
   */
  function createSnow(level) {
    const baseCount = state.isMobile ? 
      CONFIG.SNOW_BASE_COUNT_MOBILE : 
      CONFIG.SNOW_BASE_COUNT_DESKTOP;
    
    const count = Math.floor(baseCount * CONFIG.SNOW_MULTIPLIERS[level]);

    state.snowflakes = Array.from({ length: count }, () => ({
      x: Math.random() * snowCanvas.width,
      y: Math.random() * snowCanvas.height,
      radius: Math.random() * 3 + 1,
      speed: ((Math.random() * 1 + 0.5) + (Math.random() * 1.5)) * (level === 3 ? 1.3 : 1),
      swayOffset: Math.random() * Math.PI * 2,
      swaySpeed: Math.random() * 0.02 + 0.005
    }));
  }

  /**
   * Draw snow frame (RAF loop)
   */
  function drawSnow() {
    if (!state.snowActive || !state.isTabVisible) return;

    snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
    snowCtx.fillStyle = "rgba(255, 255, 255, 0.95)";
    snowCtx.beginPath();

    for (const f of state.snowflakes) {
      f.y += f.speed;
      f.swayOffset += f.swaySpeed;
      f.x += Math.sin(f.swayOffset) * 0.5;

      if (f.y > snowCanvas.height) {
        f.y = -10;
        f.x = Math.random() * snowCanvas.width;
      }
      
      if (f.x > snowCanvas.width) f.x = 0;
      if (f.x < 0) f.x = snowCanvas.width;

      snowCtx.moveTo(f.x, f.y);
      snowCtx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
    }

    snowCtx.fill();
    requestAnimationFrame(drawSnow);
  }

  /**
   * Set snow on/off with intensity level
   */
  function setSnow(on, level = 1) {
    if (!on) {
      state.snowActive = false;
      state.currentSnowLevel = 0;
      document.body.classList.remove("snowing");
      return;
    }

    // Regenerate flakes if level changed
    if (state.currentSnowLevel !== level) {
      state.currentSnowLevel = level;
      createSnow(level);
    }

    // Start animation loop
    if (!state.snowActive) {
      state.snowActive = true;
      document.body.classList.add("snowing");
      drawSnow();
    }
  }

  /* ===================================================
     NOTIFICATION HANDLING
  =================================================== */
  
  const PREVIEW_ICON = L.icon({
    iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-grey.png",
    shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
  });

  const CONFIRMED_ICON = L.icon({
    iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png",
    shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
  });

  /**
   * Show notification marker (preview or confirmed)
   */
  function showNotifyMarker(lat, lng, confirmed = false) {
    if (state.notifyMarker) {
      state.map.removeLayer(state.notifyMarker);
    }

    state.notifyMarker = L.marker([lat, lng], {
      icon: confirmed ? CONFIRMED_ICON : PREVIEW_ICON,
      interactive: true
    }).addTo(state.map);

    if (!confirmed) {
      state.notifyMarker
        .bindPopup("üìç Tap this pin again to confirm")
        .openPopup();

      state.notifyMarker.once("click", () => {
        state.awaitingPin = false;
        showNotifyMarker(lat, lng, true);

        sessionStorage.setItem(
          "SANTA_NOTIFY_POINT",
          JSON.stringify({ lat, lng })
        );

        // Call subscription API if available
        if (state.firebaseBaseUrl) {
          subscribeUser(lat, lng);
        }

        state.pinPreview = null;

        const statusBox = document.getElementById("statusBox");
        statusBox.textContent = "üîî We'll let you know when Santa is close";
        setTimeout(() => {
          if (statusBox.textContent.includes("We'll let you know")) {
            statusBox.textContent = "";
          }
        }, 2000);
      });
    }
  }

  /**
   * Fire browser notification
   */
  function fireBrowserNotification(title, body) {
    if (!("Notification" in window)) return;
    if (Notification.permission !== "granted") return;

    try {
      new Notification(title, {
        body,
        icon: "https://i.ibb.co/6cZwpb07/Santa-Marker.png",
        badge: "https://i.ibb.co/6cZwpb07/Santa-Marker.png",
        requireInteraction: true
      });
    } catch (e) {
      console.warn("Notification failed:", e);
    }
  }

  /**
   * Subscribe user to notifications (placeholder - implement with your backend)
   */
  function subscribeUser(lat, lng) {
    if (!state.firebaseBaseUrl) return;
    
    // TODO: Implement your Firebase notification subscription
    console.log("Subscribe user at:", lat, lng);
  }

  /* ===================================================
     UI MANAGEMENT
  =================================================== */
  
  /**
   * Set dim UI mode
   */
  function setDimUI(dim) {
    document.body.classList.toggle("dim-ui", !!dim);
  }

  /**
   * Update status display
   */
  function updateStatus(text) {
    const statusBox = document.getElementById("statusBox");
    statusBox.textContent = text;
  }

  /* ===================================================
     VISIBILITY & BATTERY MONITORING
  =================================================== */
  
  /**
   * Handle visibility change (pause animations when tab hidden)
   */
  function handleVisibilityChange() {
    state.isTabVisible = !document.hidden;
    
    if (!state.isTabVisible) {
      // Pause snow animation when tab hidden
      if (state.snowActive) {
        state.snowActive = false;
      }
    } else {
      // Resume snow if it was active
      if (state.currentSnowLevel > 0) {
        state.snowActive = true;
        drawSnow();
      }
    }
  }

  /**
   * Monitor battery level for performance adjustments
   */
  async function monitorBattery() {
    if (!('getBattery' in navigator)) return;
    
    try {
      const battery = await navigator.getBattery();
      state.batteryLevel = battery.level;
      
      battery.addEventListener('levelchange', () => {
        state.batteryLevel = battery.level;
        
        // Reduce snow if battery low
        if (battery.level < 0.2 && state.currentSnowLevel > 2) {
          setSnow(true, 1); // Drop to light snow
        }
      });
    } catch (e) {
      console.warn("Battery API not available");
    }
  }

  /* ===================================================
     API HANDLING
  =================================================== */
  
  /**
   * Get and validate API URL
   */
  function getApiUrl() {
    const params = new URLSearchParams(location.search);
    let apiUrl = params.get("api");

    if (!apiUrl) {
      apiUrl = sessionStorage.getItem("SANTA_API");
    }
    
    if (!apiUrl) {
      alert("Missing ?api=YOUR_SCRIPT_URL");
      throw new Error("API URL required");
    }

    // Store in session and clean URL
    sessionStorage.setItem("SANTA_API", apiUrl);
    if (location.search.includes("api=")) {
      history.replaceState(null, "", location.pathname);
    }

    return apiUrl;
  }

  /* ===================================================
     INITIALIZATION
  =================================================== */
  
  async function init() {
    try {
      // Detect environment
      state.isMobile = detectMobile();
      state.apiUrl = getApiUrl();
      
      // Load API data
      const data = await loadJSON(state.apiUrl);
      const settings = data.settings || {};

      // Log analytics view
      fetch(
        state.apiUrl +
          "?function=logView" +
          "&source=tracker" +
          "&route=" +
          encodeURIComponent((data.routes || [])[0]?.routeName || "") +
          "&ua=" +
          encodeURIComponent(navigator.userAgent),
        { keepalive: true }
      ).catch(() => {});

      // Store Firebase URL
      state.firebaseBaseUrl = data.tracker?.firebase_url || null;

      // Find today's route
      const today = new Date().toISOString().slice(0, 10);
      const todayRoute = (data.routes || []).find(r =>
        r.date === today && r.gpxUrl
      );

      // Load GPX if available
      if (todayRoute) {
        try {
          await loadGpxRoute(todayRoute.gpxUrl);
        } catch (e) {
          console.warn("GPX load failed:", e.message);
          document.getElementById("notifyBtn").style.display = "none";
        }
      } else {
        document.getElementById("notifyBtn").style.display = "none";
      }

      // Initialize map
      state.map = L.map("map").setView(CONFIG.LAPLAND_COORDS, 5);
      L.tileLayer(
        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
        { maxZoom: 19 }
      ).addTo(state.map);

      // Add GPX visual overlay
      if (todayRoute && state.gpxLoaded) {
        state.gpxLayer = new L.GPX(todayRoute.gpxUrl, {
          async: true,
          polyline_options: {
            color: settings.accent_color || "#ffd700",
            weight: 4,
            opacity: 0.85
          },
          marker_options: {
            startIcon: L.icon({
              iconUrl: settings.sleigh_icon_start || CONFIG.FALLBACK_ICONS.start,
              iconSize: [48, 48],
              iconAnchor: [24, 48]
            }),
            endIcon: L.icon({
              iconUrl: settings.sleigh_icon_end || CONFIG.FALLBACK_ICONS.end,
              iconSize: [48, 48],
              iconAnchor: [24, 48]
            }),
            shadowUrl: null
          }
        });

        state.gpxLayer.addTo(state.map);
      }

      // Restore saved notification pin
      const savedPin = sessionStorage.getItem("SANTA_NOTIFY_POINT");
      if (savedPin) {
        try {
          const p = JSON.parse(savedPin);
          state.browserNotified = false;
          sessionStorage.removeItem("SANTA_BROWSER_NOTIFIED");
          showNotifyMarker(p.lat, p.lng, true);
        } catch (e) {
          console.warn("Failed to restore pin:", e);
        }
      }

      // Map click handler for notification pin
      const mapClickHandler = (e) => {
        if (!state.awaitingPin) return;

        const { lat, lng } = e.latlng;
        state.pinPreview = { lat, lng };
        showNotifyMarker(lat, lng, false);

        updateStatus("üìç Pin moved ‚Äî tap again to confirm");
      };
      
      state.map.on("click", mapClickHandler);
      state.cleanupFunctions.push(() => state.map.off("click", mapClickHandler));

      // Add logo overlay if configured
      if (settings.logo_overlay_url) {
        const LOGO_POSITIONS = {
          "top-left": "topleft",
          "top-right": "topright",
          "bottom-left": "bottomleft",
          "bottom-right": "bottomright",
          "center": "topright"
        };

        const logoPosition = LOGO_POSITIONS[settings.logo_overlay_position] || "bottomright";
        const LogoControl = L.control({ position: logoPosition });

        LogoControl.onAdd = function() {
          const img = L.DomUtil.create("img");
          img.src = settings.logo_overlay_url;
          img.className = "logo-overlay";
          return img;
        };

        LogoControl.addTo(state.map);
      }

      // Create marker (will be positioned on first update)
      state.marker = L.marker(CONFIG.LAPLAND_COORDS, {
        icon: L.icon({
          iconUrl: settings.sleigh_icon_live || CONFIG.FALLBACK_ICONS.live,
          iconSize: [48, 48],
          iconAnchor: [24, 48]
        })
      }).addTo(state.map);

      // Setup UI controls
      setupControls(settings);

      // Setup event listeners
      window.addEventListener("resize", resizeSnow);
      document.addEventListener("visibilitychange", handleVisibilityChange);
      state.cleanupFunctions.push(() => {
        window.removeEventListener("resize", resizeSnow);
        document.removeEventListener("visibilitychange", handleVisibilityChange);
      });

      // Monitor battery if available
      monitorBattery();

      // Hide loading screen
      document.getElementById("loadingCover").style.display = "none";

      // Start tracking loop
      updateTracking();

      console.log("Santa Tracker initialized ‚úÖ");

    } catch (error) {
      console.error("Init failed:", error);
      updateStatus("‚ùå Failed to load tracker");
    }
  }

  /**
   * Setup UI button controls
   */
  function setupControls(settings) {
    const followBtn = document.getElementById("followBtn");
    const recenterBtn = document.getElementById("recenterBtn");
    const notifyBtn = document.getElementById("notifyBtn");
    const donateLink = document.getElementById("donateLink");

    // Follow button
    followBtn.addEventListener("click", () => {
      state.follow = !state.follow;
      followBtn.textContent = `Follow: ${state.follow ? "ON" : "OFF"}`;
      
      if (state.follow && state.marker) {
        state.map.setView(state.marker.getLatLng(), state.map.getZoom());
      }
    });

    // Recenter button
    recenterBtn.addEventListener("click", () => {
      if (state.marker) {
        state.map.setView(state.marker.getLatLng(), state.map.getZoom());
        state.follow = true;
        followBtn.textContent = "Follow: ON";
      }
    });

    // Notify button
    notifyBtn.addEventListener("click", async () => {
      if (state.awaitingPin) {
        state.awaitingPin = false;
        if (state.notifyMarker && !state.notifyMarker.options.icon.options.iconUrl.includes("red")) {
          state.map.removeLayer(state.notifyMarker);
          state.notifyMarker = null;
        }
        updateStatus("");
        return;
      }

      // Request notification permission
      if ("Notification" in window && Notification.permission === "default") {
        const perm = await Notification.requestPermission();
        if (perm !== "granted") {
          updateStatus("‚ùå Notification permission denied");
          return;
        }
      }

      state.awaitingPin = true;
      updateStatus("üìç Tap the map to set your location");
    });

    // Donate link
    if (settings.donate_url) {
      donateLink.href = settings.donate_url;
    } else {
      document.getElementById("donateBox").style.display = "none";
    }
  }

  /**
   * Main tracking update loop
   */
  async function updateTracking() {
    try {
      const data = await loadJSON(state.apiUrl);
      const tracker = data.tracker || {};

      // Extract coordinates
      let lat = tracker.latitude;
      let lng = tracker.longitude;

      if (!isValidCoordinate(lat, lng)) {
        updateStatus("üì° Waiting for GPS signal‚Ä¶");
        setTimeout(updateTracking, CONFIG.REFRESH_MS);
        return;
      }

      const now = Date.now();
      
      // Add to recent fixes
      addGpsFix(lat, lng, now);

      // Get visual position (snapped to route)
      const visualPos = getVisualLatLng({ lat, lng });

      // Animate marker
      animateMarkerTo(L.latLng(visualPos.lat, visualPos.lng));

      // Handle first fix
      if (state.firstFix) {
        state.map.setView([visualPos.lat, visualPos.lng], 13);
        state.firstFix = false;
      }

      // Update status dot
      const isMoving = isSleighMoving();
      const statusDot = document.getElementById("statusDot");
      statusDot.style.display = "block";
      statusDot.className = isMoving ? "status-dot dot-moving" : "status-dot dot-stopped";

      // Check for proximity notifications
      checkProximityNotification(lat, lng);

      // Update night mode and snow
      if (isAfterSunset(lat, lng)) {
        document.body.classList.add("night-mode");
        
        // Enable light snow at night (battery permitting)
        if (!state.snowActive && state.batteryLevel > 0.3) {
          setSnow(true, 1);
        }
      } else {
        document.body.classList.remove("night-mode");
        setSnow(false);
      }

      // Clear stale warning
      state.staleSince = null;
      updateStatus("");

      state.lastGoodFix = { lat, lng, ts: now };

    } catch (error) {
      console.warn("Tracking update failed:", error);
      
      // Handle stale data
      if (!state.staleSince) {
        state.staleSince = Date.now();
      }
      
      if (Date.now() - state.staleSince > CONFIG.STALE_TIMEOUT_MS) {
        updateStatus("‚ö†Ô∏è GPS data is stale");
      }
    }

    // Schedule next update
    setTimeout(updateTracking, CONFIG.REFRESH_MS);
  }

  /**
   * Check if Santa is close to notification point
   */
  function checkProximityNotification(lat, lng) {
    const saved = sessionStorage.getItem("SANTA_NOTIFY_POINT");
    if (!saved || state.browserNotified) return;

    try {
      const point = JSON.parse(saved);
      const dist = haversineMeters({ lat, lng }, point);

      // Within 100m and not yet notified
      if (dist < 100) {
        fireBrowserNotification(
          "üéÖ Santa is nearby!",
          "Santa's sleigh is approaching your location!"
        );
        
        state.browserNotified = true;
        sessionStorage.setItem("SANTA_BROWSER_NOTIFIED", "1");
      }
    } catch (e) {
      console.warn("Notification check failed:", e);
    }
  }

  /**
   * Cleanup function (call on page unload)
   */
  function cleanup() {
    // Cancel animation frame
    if (state.animRaf) {
      cancelAnimationFrame(state.animRaf);
    }

    // Stop snow
    state.snowActive = false;

    // Run all cleanup functions
    state.cleanupFunctions.forEach(fn => fn());

    console.log("Cleanup complete");
  }

  // Expose cleanup globally
  window.addEventListener("beforeunload", cleanup);

  /* ===================================================
     START APPLICATION
  =================================================== */
  
  // Initialize snow canvas
  resizeSnow();

  // Start when DOM ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }

})();
</script>

</body>
</html>
