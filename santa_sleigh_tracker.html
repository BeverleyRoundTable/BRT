<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Santa Sleigh Tracker</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.7.0/gpx.min.js"></script>
<script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
  
<style>
/* ================= GLOBAL ================= */
html,body{
  margin:0; padding:0; height:100%;
  background:#001; color:#fff;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;
  overflow:hidden;
}

:root{
  --ui-bottom-safe: 72px;
  --donate-bottom: calc(var(--ui-bottom-safe) + 92px);
  --info-bottom: var(--ui-bottom-safe);
}

@supports(padding: env(safe-area-inset-bottom)){
  :root{
    --ui-bottom-safe: calc(88px + env(safe-area-inset-bottom));
    --donate-bottom: calc(var(--ui-bottom-safe) + 92px);
    --info-bottom: var(--ui-bottom-safe);
  }
}

/* ================= MAP & OVERLAYS ================= */
#map{ position:absolute; inset:0; }

.logo-overlay{
  position:relative; width:48px; max-width:18vw;
  pointer-events:none; opacity:.9;
  filter:drop-shadow(0 2px 6px rgba(0,0,0,.5));
}

/* ================= UI COMPONENTS ================= */
.status-popup{
  position:absolute; top:20px; left:50%;
  transform:translateX(-50%);
  background:rgba(24,24,24,.95);
  padding:14px 20px;
  font-size:1.05em; font-weight:800;
  border-radius:16px;
  max-width:90%;
  box-shadow:0 4px 24px #0006;
  z-index:4000; text-align:center;
}

.donate-box{
  position:fixed; bottom:var(--donate-bottom);
  left:50%; transform:translateX(-50%);
  width:70%; max-width:420px;
  z-index:2000;
}
.donate-btn{
  background:#d31c1c; color:#fff;
  padding:14px 0; display:block;
  text-align:center; border-radius:16px;
  font-weight:900; text-decoration:none;
  box-shadow:0 4px 16px rgba(0,0,0,.4);
}

.info-popup{
  position:fixed; bottom:var(--info-bottom);
  left:50%; transform:translateX(-50%);
  background:rgba(20,20,20,.94);
  padding:10px 14px;
  border-radius:14px;
  display:flex; align-items:center; gap:12px;
  font-size:.85em; font-weight:800;
  z-index:2000;
  max-width:calc(100vw - 32px);
  box-sizing:border-box;
}

.btn{
  background:#0b1220; color:#fff;
  border:1px solid #ffffff26;
  border-radius:10px; padding:7px 12px;
  cursor:pointer; font-weight:800;
}

/* ================= STATUS INDICATORS ================= */
.status-dot{
  width:12px; aspect-ratio:1/1;
  border-radius:50%; flex-shrink:0; display:none;
}
.dot-moving{ background:#2cff4e; animation:pulse 1.4s infinite; }
.dot-stopped{ background:#ff3b3b; }

@keyframes pulse{
  0%{ box-shadow:0 0 0 0 rgba(44,255,78,.6); }
  70%{ box-shadow:0 0 0 10px rgba(44,255,78,0); }
  100%{ box-shadow:0 0 0 0 rgba(44,255,78,0); }
}

/* ================= LOADING ================= */
#loadingCover{
  position:fixed; inset:0; background:#000;
  display:flex; align-items:center; justify-content:center;
  z-index:6000;
}
#loadingSpinner{
  width:52px; height:52px; border-radius:50%;
  border:4px solid rgba(255,255,255,.25);
  border-top-color:#ffd700;
  animation:spin .9s linear infinite;
}
@keyframes spin{to{transform:rotate(360deg)}}

/* ================= RESPONSIVE ================= */
@media (max-height: 700px){
  :root{ --ui-bottom-safe: calc(64px + env(safe-area-inset-bottom)); }
  .donate-box{ width:85%; max-width:360px; }
  .info-popup{ font-size:.8em; padding:8px 12px; }
  .status-popup{ font-size:.95em; padding:12px 16px; }
}

/* ================= MODES & FX ================= */
/* Dim Mode */
body.dim-ui .donate-box,
body.dim-ui .info-popup,
body.dim-ui .status-popup{ opacity: 0.45; filter: saturate(0.85); }
body.dim-ui .donate-box:hover,
body.dim-ui .info-popup:hover,
body.dim-ui .status-popup:hover{ opacity: 0.75; }
body.dim-ui * { transition: opacity 600ms ease, filter 600ms ease; }
body.dim-ui #map { filter: brightness(0.85); }

/* Night Mode */
body.night-mode #map { filter: brightness(0.75) saturate(0.9) hue-rotate(-8deg); }
body.night-mode .status-popup { background: rgba(12,16,28,0.95); }

/* Snow */
#snow {
  position: fixed; inset: 0; pointer-events: none;
  z-index: 1500; opacity: 0; transition: opacity 800ms ease;
}
body.snowing #snow { opacity: 1; filter: drop-shadow(0 0 4px white); }
body::after {
  content: ''; position: fixed; inset: 0;
  background: radial-gradient(circle, transparent 40%, rgba(0,0,0,0.6) 100%);
  pointer-events: none; opacity: 0;
  transition: opacity 1.5s ease; z-index: 1400;
}
body.snowing::after { opacity: 1; }
</style>
</head>

<body>

<div id="loadingCover"><div id="loadingSpinner"></div></div>
<div class="status-popup" id="statusBox">üîç Searching for Santa‚Ä¶</div>

<div class="donate-box" id="donateBox">
  <a id="donateLink" class="donate-btn" target="_blank">üéÅ DONATE & SUPPORT US</a>
</div>

<div class="info-popup">
  <div id="statusDot" class="status-dot"></div>
  <button class="btn" id="followBtn">Follow: ON</button>
  <button class="btn" id="recenterBtn">Re-centre</button>
  <button class="btn" id="notifyBtn">üîî Notify Me</button>
</div>

<div id="map"></div>
<canvas id="snow"></canvas>

<script>
/**
 * SANTA TRACKER 2025
 * Hybrid Architecture: Domain-Specific Logic + Modular Design
 */
(function() {
  'use strict';

  /* ================= CONFIGURATION ================= */
  const CONFIG = {
    REFRESH_MS: 3000,
    STALE_TIMEOUT_MS: 5 * 60 * 1000,
    MOTION_WINDOW_MS: 25 * 1000,
    MOVE_THRESHOLD_METERS: 8,
    OFF_ROUTE_THRESHOLD: 60,
    MIN_FIXES_FOR_ETA: 3,
    MIN_ETA_WINDOW_MS: 15 * 1000,
    ANIMATION_DURATION: 900,
    LAPLAND: [66.5436, 25.8473],
    FALLBACK_ICONS: {
      live: "https://i.ibb.co/Qj3vDbSR/Santa-Marker-11.png",
      start: "https://i.ibb.co/PzDYmwzZ/Santa-Marker-4.png",
      end: "https://i.ibb.co/39WF0kBd/Santa-Marker-5.png"
    }
  };

  /* ================= STATE MANAGEMENT ================= */
  const state = {
    map: null,
    marker: null,
    notifyMarker: null,
    
    // API
    apiUrl: null,
    firebaseBaseUrl: null,
    
    // Tracking
    follow: true,
    firstFix: true,
    recentFixes: [],
    lastGoodFix: null,
    staleSince: null,
    
    // Animation
    animCurrent: null,
    animTarget: null,
    animStart: 0,
    animRaf: null,
    
    // Route (GPX)
    gpxRoute: null,
    gpxTotalDist: 0,
    gpxLoaded: false,
    lastSnapIndex: 0,
    
    // Notifications
    awaitingPin: false,
    browserNotified: sessionStorage.getItem("SANTA_BROWSER_NOTIFIED") === "1",
    
    // Environment / Snow
    snowActive: false,
    snowLevel: 0,
    snowflakes: [],
    
    // Performance
    isTabVisible: true,
    batteryLevel: 1, // 0 to 1
    isMobile: window.innerWidth < 600
  };

  /* ================= UTILITIES ================= */
  const valid = (lat, lng) => typeof lat === "number" && !isNaN(lat) && typeof lng === "number" && !isNaN(lng);
  
  const lerp = (a, b, t) => a + (b - a) * t;
  const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

  function haversineMeters(a, b) {
    const R = 6371000;
    const dLat = (b.lat - a.lat) * Math.PI / 180;
    const dLng = (b.lng - a.lng) * Math.PI / 180;
    const s = Math.sin(dLat / 2) ** 2 +
              Math.cos(a.lat * Math.PI / 180) * Math.cos(b.lat * Math.PI / 180) *
              Math.sin(dLng / 2) ** 2;
    return 2 * R * Math.asin(Math.sqrt(s));
  }

  async function loadJSON(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(r.status);
    return r.json();
  }

  function isAfterSunset(lat, lng) {
    const now = new Date();
    const sunset = SunCalc.getTimes(now, lat, lng).sunset;
    return now > sunset;
  }

  /* ================= SYSTEM: API & INIT ================= */
  function getApiUrl() {
    const params = new URLSearchParams(location.search);
    let url = params.get("api");
    if (!url) url = sessionStorage.getItem("SANTA_API");
    if (!url) { alert("Missing ?api=YOUR_SCRIPT_URL"); throw new Error("API missing"); }
    
    sessionStorage.setItem("SANTA_API", url);
    if (location.search.includes("api=")) history.replaceState(null, "", location.pathname);
    return url;
  }

  async function init() {
    try {
      state.apiUrl = getApiUrl();
      const data = await loadJSON(state.apiUrl);
      const s = data.settings || {};
      state.firebaseBaseUrl = data.tracker?.firebase_url;

      // Analytics
      fetch(`${state.apiUrl}?function=logView&source=tracker&ua=${encodeURIComponent(navigator.userAgent)}`, { keepalive: true }).catch(()=>{});

      // Load GPX
      const today = new Date().toISOString().slice(0, 10);
      const todayRoute = (data.routes || []).find(r => r.date === today && r.gpxUrl);

      if (todayRoute) {
        try {
          await loadGpxRoute(todayRoute.gpxUrl);
          setupGpxVisuals(todayRoute, s);
        } catch (e) {
          console.warn("GPX Error", e);
          document.getElementById('notifyBtn').style.display = 'none';
        }
      } else {
        document.getElementById('notifyBtn').style.display = 'none';
      }

      // Map Setup
      state.map = L.map("map").setView(CONFIG.LAPLAND, 5);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19 }).addTo(state.map);

      // Logo Overlay
      if (s.logo_overlay_url) setupLogo(s);

      // Marker
      state.marker = L.marker(CONFIG.LAPLAND, {
        icon: L.icon({
          iconUrl: s.sleigh_icon_live || CONFIG.FALLBACK_ICONS.live,
          iconSize: [64, 64], iconAnchor: [32, 60]
        })
      }).addTo(state.map);

      // Controls
      setupControls(s);
      
      // Load Saved Pin
      restoreNotifyPin();

      // Battery & Visibility Listeners
      setupPerformanceMonitors();

      document.getElementById("loadingCover").style.display = "none";
      
      // Start Loop
      updateTracking();

    } catch (e) {
      console.error(e);
      document.getElementById("statusBox").textContent = "‚ùå Error loading tracker";
    }
  }

  /* ================= SYSTEM: TRACKING LOOP ================= */
  async function updateTracking() {
    try {
      // 1. Fetch Data (Preserving your specific proxy param)
      const p = await loadJSON(state.apiUrl + "?function=proxyFirebase");
      if (!valid(p.lat, p.lng)) throw new Error("Invalid Coords");

      const ts = new Date(p.ts).getTime();
      const now = Date.now();
      const age = now - ts;
      const gpsFresh = age <= CONFIG.STALE_TIMEOUT_MS;

      // 2. Handle Stale State
      if (!gpsFresh) {
        if (!state.staleSince) state.staleSince = ts;
        if (now - state.staleSince > CONFIG.STALE_TIMEOUT_MS) throw new Error("Stale Data");
        
        // Fallback to last known good
        if (state.lastGoodFix) {
          state.marker.setLatLng(state.lastGoodFix);
          updateUIStatus("üéÖ Santa is nearby‚Ä¶", false);
          setTimeout(updateTracking, CONFIG.REFRESH_MS);
          return;
        }
      } else {
        state.staleSince = null;
        state.lastGoodFix = { lat: p.lat, lng: p.lng };
      }

      // 3. Environment (Night Mode)
      // Check Sunset at SANTA's location, not user's
      if (gpsFresh && isAfterSunset(p.lat, p.lng)) {
        document.body.classList.add("night-mode");
      } else {
        document.body.classList.remove("night-mode");
      }

      // 4. Update Physics & History
      state.recentFixes.push({ lat: p.lat, lng: p.lng, ts: now });
      if (state.recentFixes.length > 20) state.recentFixes.shift();
      
      // Filter old fixes for speed calc
      state.recentFixes = state.recentFixes.filter(f => now - f.ts <= CONFIG.MOTION_WINDOW_MS);

      // 5. Calculate Movement & Speed
      const visualPos = getVisualLatLng({ lat: p.lat, lng: p.lng });
      const speed = calculateStableSpeed(state.recentFixes);
      const moving = isSleighMoving();

      // 6. Animate
      animateMarkerTo(L.latLng(visualPos.lat, visualPos.lng));

      // 7. GPX / ETA Logic
      let etaSeconds = Infinity;
      let offRoute = false;
      let passedSubscriber = false;

      if (state.gpxLoaded) {
        const snap = snapToGpxIndex({ lat: p.lat, lng: p.lng });
        
        if (snap && snap.distance <= CONFIG.OFF_ROUTE_THRESHOLD) {
          // Check Subscriber Pass
          if (state.notifyMarker) {
             const userSnap = snapSubscriberToGpx(state.notifyMarker.getLatLng());
             if (userSnap && snap.point.dist > userSnap.point.dist + 30) passedSubscriber = true;
          }

          // Calculate ETA
          if (!passedSubscriber && speed !== null && moving && gpsFresh) {
            const remaining = Math.max(0, state.gpxTotalDist - snap.point.dist);
            etaSeconds = remaining / speed;
          }
        } else {
          offRoute = true;
        }
      }

      // 8. Snow Logic (The "Drama" Engine)
      const etaMinutes = isFinite(etaSeconds) ? etaSeconds / 60 : Infinity;
      const isNight = document.body.classList.contains("night-mode");
      
      let snowOn = false;
      let snowLevel = 1;

      // Only snow if: Fresh + Night + Moving + Close + Battery OK
      if (gpsFresh && isNight && moving && etaMinutes < 15 && state.batteryLevel > 0.15) {
        snowOn = true;
        // YOUR SPECIFIC DRAMA LOGIC RESTORED:
        if (etaMinutes < 2) snowLevel = 3;       // ‚ùÑÔ∏è BLIZZARD
        else if (etaMinutes < 7) snowLevel = 2;  // üå®Ô∏è HEAVY
        else snowLevel = 1;                      // üåßÔ∏è LIGHT
      }
      setSnow(snowOn, snowLevel);

      // 9. Browser Notification
      checkBrowserNotification(p.lat, p.lng, passedSubscriber);

      // 10. Update UI Text / Status Dot
      updateUIDisplay(moving, passedSubscriber, etaSeconds, offRoute);
      
      // First Fix Zoom
      if (state.firstFix) {
        state.map.setView([visualPos.lat, visualPos.lng], 16);
        state.firstFix = false;
      }

    } catch (e) {
      // Fallback Mode
      state.marker.setLatLng(CONFIG.LAPLAND);
      if (state.follow) state.map.setView(CONFIG.LAPLAND, 5, {animate:true});
      setSnow(false);
      updateUIStatus("üéÑ Santa is in Lapland preparing!", false);
      document.getElementById("statusDot").style.display = "none";
      state.firstFix = true;
    }

    setTimeout(updateTracking, CONFIG.REFRESH_MS);
  }

  /* ================= FEATURE: PHYSICS & GPX ================= */
  async function loadGpxRoute(url) {
    const res = await fetch(url);
    const text = await res.text();
    const xml = new DOMParser().parseFromString(text, "text/xml");
    const pts = [...xml.getElementsByTagName("trkpt")];

    let dist = 0;
    let route = [];
    for (let i = 0; i < pts.length; i++) {
      const lat = parseFloat(pts[i].getAttribute("lat"));
      const lng = parseFloat(pts[i].getAttribute("lon"));
      if (i > 0) dist += haversineMeters(route[i - 1], { lat, lng });
      route.push({ lat, lng, dist });
    }
    state.gpxRoute = route;
    state.gpxTotalDist = dist;
    state.gpxLoaded = true;
  }

  function snapToGpxIndex(pos) {
    if (!state.gpxRoute) return null;
    let best = state.lastSnapIndex;
    let bestDist = Infinity;

    // Optimized search window
    const lookAhead = 50; 
    const limit = Math.min(state.gpxRoute.length, state.lastSnapIndex + lookAhead);

    for (let i = state.lastSnapIndex; i < limit; i++) {
      const d = haversineMeters(pos, state.gpxRoute[i]);
      if (d < bestDist) { bestDist = d; best = i; }
    }
    state.lastSnapIndex = best;
    return { point: state.gpxRoute[best], distance: bestDist };
  }

  function getVisualLatLng(rawPos) {
    if (!state.gpxLoaded) return rawPos;
    const snap = snapToGpxIndex(rawPos);
    return (snap && snap.distance <= CONFIG.OFF_ROUTE_THRESHOLD) ? snap.point : rawPos;
  }

  function snapSubscriberToGpx(pos) {
    if (!state.gpxRoute) return null;
    let best = 0, bestDist = Infinity;
    for (let i = 0; i < state.gpxRoute.length; i++) {
      const d = haversineMeters(pos, state.gpxRoute[i]);
      if (d < bestDist) { bestDist = d; best = i; }
    }
    return { point: state.gpxRoute[best], distance: bestDist };
  }

  function isSleighMoving() {
    if (state.recentFixes.length < 2) return false;
    let d = 0;
    for (let i = 1; i < state.recentFixes.length; i++) d += haversineMeters(state.recentFixes[i-1], state.recentFixes[i]);
    return d >= CONFIG.MOVE_THRESHOLD_METERS;
  }

  function calculateStableSpeed(fixes) {
    if (fixes.length < CONFIG.MIN_FIXES_FOR_ETA) return null;
    const first = fixes[0], last = fixes[fixes.length - 1];
    const elapsed = last.ts - first.ts;
    if (elapsed < CONFIG.MIN_ETA_WINDOW_MS) return null;
    
    let dist = 0;
    for (let i = 1; i < fixes.length; i++) dist += haversineMeters(fixes[i-1], fixes[i]);
    return Math.min(Math.max(dist / (elapsed / 1000), 0.3), 6);
  }

  /* ================= FEATURE: ANIMATION ================= */
  function animateMarkerTo(targetLL) {
    if (!state.marker) return;
    if (!state.animCurrent) state.animCurrent = state.marker.getLatLng();

    state.animTarget = targetLL;
    state.animStart = performance.now();
    if (state.animRaf) cancelAnimationFrame(state.animRaf);

    const start = state.marker.getLatLng();

    function step(now) {
      if (!state.isTabVisible) return; // Pause if hidden

      const t = Math.min(1, (now - state.animStart) / CONFIG.ANIMATION_DURATION);
      const e = easeOutCubic(t);
      const lat = lerp(start.lat, state.animTarget.lat, e);
      const lng = lerp(start.lng, state.animTarget.lng, e);
      const ll = L.latLng(lat, lng);

      state.marker.setLatLng(ll);
      state.animCurrent = ll;

      if (state.follow && !state.firstFix) state.map.panTo(ll, { animate: true, duration: 0.6 });

      if (t < 1) state.animRaf = requestAnimationFrame(step);
      else state.animRaf = null;
    }
    state.animRaf = requestAnimationFrame(step);
  }

  /* ================= FEATURE: SNOW (CANVAS) ================= */
  const snowCanvas = document.getElementById("snow");
  const snowCtx = snowCanvas.getContext("2d");

  function resizeSnow() {
    snowCanvas.width = window.innerWidth;
    snowCanvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resizeSnow);

  function createSnow(level) {
    // Battery Check: If low battery, force Level 1 max
    if (state.batteryLevel < 0.2 && level > 1) level = 1;

    const isMobile = state.isMobile;
    const baseCount = isMobile ? 30 : 60;
    const multipliers = [0, 1, 2.5, 5];
    const count = Math.floor(baseCount * multipliers[level]);

    state.snowflakes = Array.from({ length: count }, () => ({
      x: Math.random() * snowCanvas.width,
      y: Math.random() * snowCanvas.height,
      radius: Math.random() * 3 + 1,
      speed: ((Math.random() * 1 + 0.5) + (Math.random() * 1.5)) * (level === 3 ? 1.3 : 1),
      swayOffset: Math.random() * Math.PI * 2,
      swaySpeed: Math.random() * 0.02 + 0.005
    }));
  }

  function drawSnow() {
    if (!state.snowActive || !state.isTabVisible) return; // Save CPU

    snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
    snowCtx.fillStyle = "rgba(255, 255, 255, 0.95)";
    snowCtx.beginPath();

    for (const f of state.snowflakes) {
      f.y += f.speed;
      f.swayOffset += f.swaySpeed;
      f.x += Math.sin(f.swayOffset) * 0.5;

      if (f.y > snowCanvas.height) { f.y = -10; f.x = Math.random() * snowCanvas.width; }
      if (f.x > snowCanvas.width) f.x = 0;
      if (f.x < 0) f.x = snowCanvas.width;

      snowCtx.moveTo(f.x, f.y);
      snowCtx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
    }
    snowCtx.fill();
    requestAnimationFrame(drawSnow);
  }

  function setSnow(on, level) {
    if (!on) {
      state.snowActive = false;
      document.body.classList.remove("snowing");
      return;
    }
    if (state.snowLevel !== level) {
      state.snowLevel = level;
      createSnow(level);
    }
    if (!state.snowActive) {
      state.snowActive = true;
      document.body.classList.add("snowing");
      drawSnow();
    }
  }

  /* ================= UI & CONTROLS ================= */
  function updateUIStatus(text, dim = false) {
    document.getElementById("statusBox").textContent = text;
    document.body.classList.toggle("dim-ui", !!dim);
  }

  function updateUIDisplay(moving, passed, etaSec, offRoute) {
    const dot = document.getElementById("statusDot");
    dot.style.display = "block";
    dot.className = moving ? "status-dot dot-moving" : "status-dot dot-stopped";

    if (passed) {
      updateUIStatus("üéÑ Santa has just been here!", false);
    } else if (isFinite(etaSec)) {
      const mins = Math.round(etaSec / 60);
      updateUIStatus(
        mins > 45 ? "üéÖ Santa is out delivering this evening‚Ä¶" :
        mins > 15 ? "üéÖ Santa is on the way‚Ä¶" :
        mins > 5  ? "üéÖ Santa is nearly here!" :
        `üéÖ Santa is ${Math.max(1, mins)} min away!`,
        mins > 45 // Dim if far away
      );
    } else if (offRoute && moving) {
      updateUIStatus("üéÖ Santa is nearby‚Ä¶", false);
    } else if (moving) {
      updateUIStatus("üéÖ Santa is out spreading joy!", false);
    } else {
      updateUIStatus("üéÑ Santa has stopped to spread cheer!", false);
    }
  }

  function setupControls(s) {
    const followBtn = document.getElementById("followBtn");
    followBtn.onclick = () => {
      state.follow = !state.follow;
      followBtn.textContent = "Follow: " + (state.follow ? "ON" : "OFF");
    };
    
    document.getElementById("recenterBtn").onclick = () => {
      state.follow = true;
      if(state.marker) state.map.panTo(state.marker.getLatLng());
    };

    const notifyBtn = document.getElementById("notifyBtn");
    notifyBtn.onclick = startNotifyFlow;

    if (s.donate_url) document.getElementById("donateLink").href = s.donate_url;
    else document.getElementById("donateBox").style.display = "none";
  }

  function setupPerformanceMonitors() {
    // 1. Visibility (Tab Switching)
    document.addEventListener("visibilitychange", () => {
      state.isTabVisible = !document.hidden;
      if (state.isTabVisible && state.snowActive) drawSnow(); // Restart loop
    });

    // 2. Battery (Chrome/Edge/Android)
    if ('getBattery' in navigator) {
      navigator.getBattery().then(batt => {
        state.batteryLevel = batt.level;
        batt.addEventListener('levelchange', () => state.batteryLevel = batt.level);
      });
    }
  }

  /* ================= NOTIFICATIONS ================= */
  function startNotifyFlow() {
    state.follow = false;
    document.getElementById("followBtn").textContent = "Follow: OFF";
    
    state.browserNotified = false;
    sessionStorage.removeItem("SANTA_BROWSER_NOTIFIED");
    sessionStorage.removeItem("SANTA_NOTIFY_POINT");
    
    if ("Notification" in window && Notification.permission === "default") Notification.requestPermission();
    
    state.awaitingPin = true;
    updateUIStatus("üìç Tap the map to place your pin");

    const clickHandler = (e) => {
      if (!state.awaitingPin) return;
      const { lat, lng } = e.latlng;
      showNotifyMarker(lat, lng, false);
      updateUIStatus("üìç Pin moved ‚Äî tap again to confirm");
    };

    state.map.on("click", clickHandler);
  }

  function showNotifyMarker(lat, lng, confirmed) {
    if (state.notifyMarker) state.map.removeLayer(state.notifyMarker);
    
    const iconUrl = confirmed ? 
      "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png" : 
      "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-grey.png";

    state.notifyMarker = L.marker([lat, lng], {
      icon: L.icon({
        iconUrl, shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
      }),
      interactive: true
    }).addTo(state.map);

    if (!confirmed) {
      state.notifyMarker.bindPopup("üìç Tap to confirm").openPopup();
      state.notifyMarker.once("click", () => confirmSubscription(lat, lng));
    }
  }

  function confirmSubscription(lat, lng) {
    state.awaitingPin = false;
    showNotifyMarker(lat, lng, true);
    sessionStorage.setItem("SANTA_NOTIFY_POINT", JSON.stringify({ lat, lng }));

    // Prompt for Email (optional)
    if (state.firebaseBaseUrl && sessionStorage.getItem("SANTA_EMAIL_SUBSCRIBED") !== "1") {
      const email = prompt("üìß Enter email for updates (optional):");
      
      fetch(`${state.firebaseBaseUrl}/subscribers.json`, {
        method: "POST", headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ api: state.apiUrl, lat, lng, email, created: new Date().toISOString() })
      }).then(() => {
        sessionStorage.setItem("SANTA_EMAIL_SUBSCRIBED", "1");
        alert("üéÖ Subscribed!");
      });
    }
    updateUIStatus("üîî We‚Äôll let you know when Santa is close");
  }

  function checkBrowserNotification(santaLat, santaLng, passed) {
    if (!state.notifyMarker || state.browserNotified || passed) return;
    const user = state.notifyMarker.getLatLng();
    const dist = haversineMeters({lat:santaLat, lng:santaLng}, user);
    
    if (dist < 250) {
      state.browserNotified = true;
      sessionStorage.setItem("SANTA_BROWSER_NOTIFIED", "1");
      if ("Notification" in window && Notification.permission === "granted") {
        new Notification("üéÖ Santa is nearly here!", {
           body: "He‚Äôs about 5 minutes away ‚Äî get ready! üéÑ",
           icon: "https://i.ibb.co/6cZwpb07/Santa-Marker.png"
        });
      }
    }
  }

  function restoreNotifyPin() {
    const saved = sessionStorage.getItem("SANTA_NOTIFY_POINT");
    if (saved) {
      try {
        const p = JSON.parse(saved);
        state.browserNotified = false; // Reset on reload
        sessionStorage.removeItem("SANTA_BROWSER_NOTIFIED");
        showNotifyMarker(p.lat, p.lng, true);
      } catch(e){}
    }
  }

  /* ================= HELPERS (SETUP) ================= */
  function setupLogo(s) {
    const posMap = { "top-left": "topleft", "top-right": "topright", "bottom-left": "bottomleft", "bottom-right": "bottomright", "center": "topright" };
    const LogoControl = L.control({ position: posMap[s.logo_overlay_position] || "bottomright" });
    LogoControl.onAdd = () => {
      const img = L.DomUtil.create("img");
      img.src = s.logo_overlay_url;
      img.className = "logo-overlay";
      return img;
    };
    LogoControl.addTo(state.map);
  }

  function setupGpxVisuals(route, s) {
    new L.GPX(route.gpxUrl, {
      async: true,
      polyline_options: { color: s.accent_color || "#ffd700", weight: 4, opacity: 0.85 },
      marker_options: {
        startIcon: L.icon({ iconUrl: s.sleigh_icon_start || CONFIG.FALLBACK_ICONS.start, iconSize: [48, 48], iconAnchor: [24, 48] }),
        endIcon: L.icon({ iconUrl: s.sleigh_icon_end || CONFIG.FALLBACK_ICONS.end, iconSize: [48, 48], iconAnchor: [24, 48] }),
        shadowUrl: null
      }
    }).addTo(state.map);
  }

  // START
  init();

})();
</script>
</body>
</html>
