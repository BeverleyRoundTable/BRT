<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Santa Sleigh Tracker</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.7.0/gpx.min.js"></script>
  <script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
  
<style>
html,body{
  margin:0;
  padding:0;
  height:100%;
  background:#001;
  color:#fff;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;
  overflow:hidden;
}

/* ---------- VIEWPORT SAFE ZONE ---------- */
:root{
  /* Desktop default */
  --ui-bottom-safe: 72px;

  /* ‚úÖ FIX: Donate ABOVE Follow */
  --donate-bottom: calc(var(--ui-bottom-safe) + 92px);
  --info-bottom: var(--ui-bottom-safe);
}

/* Mobile browsers with notches */
@supports(padding: env(safe-area-inset-bottom)){
  :root{
    --ui-bottom-safe: calc(88px + env(safe-area-inset-bottom));

    /* ‚úÖ FIX mirrored for mobile */
    --donate-bottom: calc(var(--ui-bottom-safe) + 92px);
    --info-bottom: var(--ui-bottom-safe);
  }
}

#map{
  position:absolute;
  inset:0;
}

/* ---------- STATUS ---------- */
.status-popup{
  position:absolute;
  top:20px;
  left:50%;
  transform:translateX(-50%);
  background:rgba(24,24,24,.95);
  padding:14px 20px;
  font-size:1.05em;
  font-weight:800;
  border-radius:16px;
  max-width:90%;
  box-shadow:0 4px 24px #0006;
  z-index:4000;
  text-align:center;
}

/* ---------- DONATE ---------- */
.donate-box{
  position:fixed;
  bottom: var(--donate-bottom);
  left:50%;
  transform:translateX(-50%);
  width:70%;
  max-width:420px;
  z-index:2000;
}
.donate-btn{
  background:#d31c1c;
  color:#fff;
  padding:14px 0;
  display:block;
  text-align:center;
  border-radius:16px;
  font-weight:900;
  text-decoration:none;
  box-shadow:0 4px 16px rgba(0,0,0,.4);
}

/* ---------- INFO BAR ---------- */
.info-popup{
  position:fixed;
  bottom: var(--info-bottom);
  left:50%;
  transform:translateX(-50%);

  background:rgba(20,20,20,.94);
  padding:10px 14px;
  border-radius:14px;
  display:flex;
  align-items:center;
  gap:12px;
  font-size:.85em;
  font-weight:800;
  z-index:2000;
  max-width:calc(100vw - 32px);
  box-sizing:border-box;
}

/* ---------- STATUS DOT ---------- */
.status-dot{
  width:12px;
  aspect-ratio:1 / 1;
  border-radius:50%;
  flex-shrink:0;
  display:none;
}
.dot-moving{
  background:#2cff4e;
  animation:pulse 1.4s infinite;
}
.dot-stopped{
  background:#ff3b3b;
}
@keyframes pulse{
  0%{ box-shadow:0 0 0 0 rgba(44,255,78,.6); }
  70%{ box-shadow:0 0 0 10px rgba(44,255,78,0); }
  100%{ box-shadow:0 0 0 0 rgba(44,255,78,0); }
}

.btn{
  background:#0b1220;
  color:#fff;
  border:1px solid #ffffff26;
  border-radius:10px;
  padding:7px 12px;
  cursor:pointer;
  font-weight:800;
}

/* ---------- LOGO OVERLAY ---------- */
.logo-overlay{
  position:relative;
  width:48px;
  max-width:18vw;
  pointer-events:none;
  opacity:.9;
  filter:drop-shadow(0 2px 6px rgba(0,0,0,.5));
}

/* ---------- LOADING ---------- */
#loadingCover{
  position:fixed;
  inset:0;
  background:#000;
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:6000;
}
#loadingSpinner{
  width:52px;
  height:52px;
  border-radius:50%;
  border:4px solid rgba(255,255,255,.25);
  border-top-color:#ffd700;
  animation:spin .9s linear infinite;
}
@keyframes spin{to{transform:rotate(360deg)}}

/* ---------- MOBILE / EMBED TIGHTENING ---------- */
@media (max-height: 700px){
  :root{
    --ui-bottom-safe: calc(64px + env(safe-area-inset-bottom));
  }

  .donate-box{
    width:85%;
    max-width:360px;
  }

  .info-popup{
    font-size:.8em;
    padding:8px 12px;
  }

  .status-popup{
    font-size:.95em;
    padding:12px 16px;
  }
}

  /* ---------- AUTO DIM MODE ---------- */
body.dim-ui .donate-box,
body.dim-ui .info-popup,
body.dim-ui .status-popup{
  opacity: 0.45;
  filter: saturate(0.85);
  transition: opacity 600ms ease, filter 600ms ease;
}

body.dim-ui .donate-box:hover,
body.dim-ui .info-popup:hover,
body.dim-ui .status-popup:hover{
  opacity: 0.75;
}

  /* ---------- CINEMATIC DIM POLISH ---------- */
body.dim-ui * {
  transition: opacity 600ms ease, filter 600ms ease;
}

body.dim-ui #map {
  filter: brightness(0.85);
}

   /* ---------- SUNSET ---------- */
  body.night-mode #map {
  filter: brightness(0.75) saturate(0.9) hue-rotate(-8deg);
}

body.night-mode .status-popup {
  background: rgba(12,16,28,0.95);
}

  #snow {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 1500; /* above map, below UI */
  opacity: 0;
  transition: opacity 800ms ease;
}

body.snowing #snow {
  opacity: 0.35; /* subtle */
}

body::after {
  content: '';
  position: fixed;
  inset: 0;
  background: radial-gradient(circle, transparent 40%, rgba(0,0,0,0.6) 100%);
  pointer-events: none;
  opacity: 0;
  transition: opacity 1.5s ease;
  z-index: 1400; /* Below snow, above map */
}

body.snowing::after {
  opacity: 1;
}

/* Update your existing #snow rule to be softer */
body.snowing #snow {
  opacity: 1; 
  filter: drop-shadow(0 0 4px white); /* Makes snow 'glow' slightly */
}
  
</style>
</head>

<body>

<div id="loadingCover"><div id="loadingSpinner"></div></div>

<div class="status-popup" id="statusBox">
  üîç Searching for Santa‚Ä¶
</div>

<div class="donate-box" id="donateBox">
  <a id="donateLink" class="donate-btn" target="_blank">
    üéÅ DONATE & SUPPORT US
  </a>
</div>

<div class="info-popup">
  <div id="statusDot" class="status-dot"></div>
  <button class="btn" id="followBtn">Follow: ON</button>
  <button class="btn" id="recenterBtn">Re-centre</button>
  <button class="btn" id="notifyBtn">üîî Notify Me</button>
</div>

<div id="map"></div>
<canvas id="snow"></canvas>

<script>
  /* ===================================================
   BATTERY SAVER - VISIBLE PAGE
=================================================== */
  let pageVisible = !document.hidden;

document.addEventListener("visibilitychange", () => {
  pageVisible = !document.hidden;

  // Hard pause snow when hidden
  if (pageVisible && currentSnowLevel > 0) {
  snowActive = false;
  document.body.classList.remove("snowing");
}

  let batteryState = {
  supported: false,
  charging: true,
  level: 1
};

if ("getBattery" in navigator) {
  navigator.getBattery().then(battery => {
    batteryState.supported = true;

    function updateBattery() {
      batteryState.charging = battery.charging;
      batteryState.level = battery.level;
    }

    updateBattery();

    battery.addEventListener("chargingchange", updateBattery);
    battery.addEventListener("levelchange", updateBattery);
  });
}

/* ===================================================
   API HANDLING ‚Äî HIDDEN + REFRESH SAFE
=================================================== */

const params = new URLSearchParams(location.search);
let apiUrl = params.get("api");

if (!apiUrl) apiUrl = sessionStorage.getItem("SANTA_API");
if (!apiUrl) { alert("Missing ?api=YOUR_SCRIPT_URL"); throw new Error("API missing"); }

sessionStorage.setItem("SANTA_API", apiUrl);
if (location.search.includes("api=")) history.replaceState(null, "", location.pathname);

  /* ===================================================
   GLOBAL CONFIG
=================================================== */

const CONFIG = {
  // Timing
  REFRESH_MS: 3000,
  STALE_MS: 5 * 60 * 1000,

  // Motion detection
  MOTION_WINDOW_MS: 25 * 1000,
  MOVE_THRESHOLD_METERS: 8,

  // ETA calculation
  MIN_FIXES_FOR_ETA: 3,
  MIN_ETA_WINDOW_MS: 15 * 1000,

  // GPX snapping
  OFF_ROUTE_THRESHOLD_METERS: 60,
  GPX_SEARCH: {
    AHEAD: 80,
    BACK: 5,
    EARLY_EXIT_METERS: 25
  },

  // Snow behaviour
  SNOW: {
    ETA_MINUTES_MAX: 15,
    LEVELS: {
      LIGHT: 1,
      HEAVY: 2,
      BLIZZARD: 3
    },
    MOBILE_BASE_COUNT: 30,
    DESKTOP_BASE_COUNT: 60,
    MULTIPLIERS: [0, 1, 2.5, 5]
  },

  // Battery throttling
  BATTERY: {
    LOW: 0.4,
    CRITICAL: 0.2,
    FRAME_SKIP: {
      LOW: 2,
      CRITICAL: 3
    }
  },

  // Map defaults
  LAPLAND: [66.5436, 25.8473]
};

  const PREVIEW_ICON = L.icon({
  iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-grey.png",
  shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

const CONFIRMED_ICON = L.icon({
  iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png",
  shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});
  
/* ===================================================
   TRACKER CONFIG (UNCHANGED)
=================================================== */

const REFRESH = CONFIG.REFRESH_MS;
const STALE_MS = 5 * 60 * 1000;
const LAPLAND = [66.5436,25.8473];

const FALLBACK = {
  live: "https://i.ibb.co/Qj3vDbSR/Santa-Marker-11.png",
  start: "https://i.ibb.co/PzDYmwzZ/Santa-Marker-4.png",
  end: "https://i.ibb.co/39WF0kBd/Santa-Marker-5.png"
};
  
const MOTION_WINDOW_MS = CONFIG.MOTION_WINDOW_MS; // 25 seconds
const MOVE_THRESHOLD_METERS = CONFIG.MOVE_THRESHOLD_METERS; // slow sleigh-safe threshold


  const OFF_ROUTE_THRESHOLD_METERS =
  CONFIG.OFF_ROUTE_THRESHOLD_METERS;

let map, marker, follow=true, firstFix=true, lastFix=null;
let awaitingPin = false;
let notifyMarker = null;
let firebaseBaseUrl = null;
let pinPreview = null;
let browserNotified = sessionStorage.getItem("SANTA_BROWSER_NOTIFIED") === "1";
let recentFixes = [];
let lastGoodFix = null;
let staleSince = null;
let animCurrent = null;     // L.LatLng
let animTarget = null;      // L.LatLng
let animStart = 0;
let animDuration = 900;     // ms (tweak: 700‚Äì1200 feels good)
let animRaf = null;

  // ================= GPX ROUTE STATE =================
let gpxRoute = null;           // [{lat,lng,dist}]
let gpxTotalDistance = 0;      // meters
let gpxLoaded = false;
let lastSnapIndex = 0;

/* ---------- HELPERS ---------- */

const snowCanvas = document.getElementById("snow");
const snowCtx = snowCanvas.getContext("2d");

let snowflakes = [];
let snowActive = false;
let currentSnowLevel = 0; // 0=Off, 1=Light, 2=Medium, 3=Blizzard

function resizeSnow() {
  snowCanvas.width = window.innerWidth;
  snowCanvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeSnow);
resizeSnow();

// ‚úÖ NEW: Accepts 'level' (1, 2, or 3) to determine density
function createSnow(level) {
  // Mobile gets fewer flakes to save battery
  const isMobile = window.innerWidth < 600;
  const baseCount = isMobile
  ? CONFIG.SNOW.MOBILE_BASE_COUNT
  : CONFIG.SNOW.DESKTOP_BASE_COUNT;
  
  // 1=Light (1x), 2=Medium (2.5x), 3=Blizzard (5x)
  const multipliers = CONFIG.SNOW.MULTIPLIERS;
  const count = Math.floor(baseCount * multipliers[level]);

  snowflakes = Array.from({ length: count }, () => ({
    x: Math.random() * snowCanvas.width,
    y: Math.random() * snowCanvas.height,
    radius: Math.random() * 3 + 1,
    // Blizzard level (3) makes snow fall slightly faster
    speed: ((Math.random() * 1 + 0.5) + (Math.random() * 1.5)) * (level === 3 ? 1.3 : 1),
    swayOffset: Math.random() * Math.PI * 2,
    swaySpeed: Math.random() * 0.02 + 0.005
  }));
}

let snowFrame = 0;

function drawSnow() {
  if (!snowActive || !pageVisible) return;

  const { frameSkip } = getSnowThrottle();
  snowFrame++;

  // ‚è±Ô∏è Skip frames to save power
  if (frameSkip && snowFrame % (frameSkip + 1) !== 0) {
    requestAnimationFrame(drawSnow);
    return;
  }

  snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
  snowCtx.fillStyle = "rgba(255, 255, 255, 0.95)";
  snowCtx.beginPath();

  for (const f of snowflakes) {
    f.y += f.speed;
    f.swayOffset += f.swaySpeed;
    f.x += Math.sin(f.swayOffset) * 0.5;

    if (f.y > snowCanvas.height) {
      f.y = -10;
      f.x = Math.random() * snowCanvas.width;
    }

    if (f.x > snowCanvas.width) f.x = 0;
    if (f.x < 0) f.x = snowCanvas.width;

    snowCtx.moveTo(f.x, f.y);
    snowCtx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
  }

  snowCtx.fill();
  requestAnimationFrame(drawSnow);
}

// ‚úÖ NEW: Handles intensity changes intelligently
function setSnow(on, level = 1) {
  // üîï Always disable when page hidden
  if (!pageVisible) {
    snowActive = false;
    currentSnowLevel = 0;
    document.body.classList.remove("snowing");
    return;
  }

  // Turning OFF
  if (!on) {
    snowActive = false;
    currentSnowLevel = 0;
    document.body.classList.remove("snowing");
    return;
  }

  // Intensity changed
  if (currentSnowLevel !== level) {
    currentSnowLevel = level;
    createSnow(level);
  }

  // Start animation loop once
  if (!snowActive) {
    snowActive = true;
    document.body.classList.add("snowing");
    drawSnow();
  }
}

/* ---------- GENERAL HELPERS ---------- */

  function getSnowThrottle() {
  // Default: full experience
  let maxLevel = 3;       // Blizzard allowed
  let frameSkip = 0;      // Draw every frame

  if (batteryState.supported && !batteryState.charging) {
    if (batteryState.level <= CONFIG.BATTERY.CRITICAL) { // üî¥ Critical battery
  maxLevel = 1;
  frameSkip = CONFIG.BATTERY.FRAME_SKIP.CRITICAL;
} else if (batteryState.level <= CONFIG.BATTERY.LOW) {  // üü† Low battery
  maxLevel = 2;
  frameSkip = CONFIG.BATTERY.FRAME_SKIP.LOW;
}
  }

  return { maxLevel, frameSkip };
}

const valid=(lat,lng)=>typeof lat==="number"&&!isNaN(lat)&&typeof lng==="number"&&!isNaN(lng);

async function loadJSON(url){
  const r = await fetch(url,{cache:"no-store"});
  if(!r.ok) throw 0;
  return r.json();
}

  function lerp(a, b, t) {
  return a + (b - a) * t;
}

function easeOutCubic(t) {
  return 1 - Math.pow(1 - t, 3);
}

function animateMarkerTo(targetLL) {
  if (!marker) return;

  // First ever set ‚Äî no easing
  if (!animCurrent) {
    animCurrent = marker.getLatLng();
  }

  animTarget = targetLL;
  animStart = performance.now();

  // Cancel any in-flight animation loop
  if (animRaf) cancelAnimationFrame(animRaf);

  const startLL = marker.getLatLng();
  const startLat = startLL.lat;
  const startLng = startLL.lng;

  const endLat = animTarget.lat;
  const endLng = animTarget.lng;

  function step(now) {
    const t = Math.min(1, (now - animStart) / animDuration);
    const e = easeOutCubic(t);

    const lat = lerp(startLat, endLat, e);
    const lng = lerp(startLng, endLng, e);

    const ll = L.latLng(lat, lng);
    marker.setLatLng(ll);
    animCurrent = ll;

    // Keep follow smooth too
    if (follow && !firstFix) {
      map.panTo(ll, { animate: true, duration: 0.6 });
    }

    if (t < 1) {
      animRaf = requestAnimationFrame(step);
    } else {
      animRaf = null;
    }
  }

  animRaf = requestAnimationFrame(step);
}

  function setDimUI(dim) {
  document.body.classList.toggle("dim-ui", !!dim);
}

  function isAfterSunset(lat, lng) {
  const now = new Date();
  const sunset = SunCalc.getTimes(now, lat, lng).sunset;
  return now > sunset;
}

 function showNotifyMarker(lat, lng, confirmed = false) {
  if (notifyMarker) map.removeLayer(notifyMarker);

  notifyMarker = L.marker([lat, lng], {
    icon: confirmed ? CONFIRMED_ICON : PREVIEW_ICON,
    interactive: true
  }).addTo(map);

  if (!confirmed) {
    notifyMarker
      .bindPopup("üìç Tap this pin again to confirm")
      .openPopup();

    // ‚úÖ CONFIRM BY CLICKING THE PIN
    notifyMarker.once("click", () => {
      awaitingPin = false;
      
      showNotifyMarker(lat, lng, true);

      sessionStorage.setItem(
        "SANTA_NOTIFY_POINT",
        JSON.stringify({ lat, lng })
      );

      subscribeUser(lat, lng);
      pinPreview = null;

      statusBox.textContent = "üîî We‚Äôll let you know when Santa is close";
      setTimeout(() => {
        if (statusBox.textContent.includes("We‚Äôll let you know")) {
          statusBox.textContent = "";
        }
      }, 2000);
    });
  }
}

  function calculateStableSpeedMps_(fixes) {
  if (fixes.length < CONFIG.MIN_FIXES_FOR_ETA) return null;

  const first = fixes[0];
  const last = fixes[fixes.length - 1];

  const elapsed = last.ts - first.ts;
  if (elapsed < CONFIG.MIN_ETA_WINDOW_MS) return null;

  const dist =
    fixes[fixes.length - 1].cumulative -
    fixes[0].cumulative;

  const speed = dist / (elapsed / 1000);

  // Clamp to realistic sleigh bounds
  return Math.min(Math.max(speed, 0.3), 6);
}
  
function haversineMeters(a, b) {
  const R = 6371000;
  const dLat = (b.lat - a.lat) * Math.PI / 180;
  const dLng = (b.lng - a.lng) * Math.PI / 180;

  const s =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(a.lat * Math.PI / 180) *
    Math.cos(b.lat * Math.PI / 180) *
    Math.sin(dLng / 2) ** 2;

  return 2 * R * Math.asin(Math.sqrt(s));
}

  function isSleighMoving() {
  if (recentFixes.length < 2) return false;

  const first = recentFixes[0];
  const last = recentFixes[recentFixes.length - 1];

  return (last.cumulative - first.cumulative) >= MOVE_THRESHOLD_METERS;
}

  async function loadGpxRoute(url) {
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error("GPX fetch failed");

  const text = await res.text();
  const xml = new DOMParser().parseFromString(text, "text/xml");
  const pts = [...xml.getElementsByTagName("trkpt")];

  if (pts.length < 2) throw new Error("GPX too short");

  let dist = 0;
  let route = [];

  for (let i = 0; i < pts.length; i++) {
    const lat = parseFloat(pts[i].getAttribute("lat"));
    const lng = parseFloat(pts[i].getAttribute("lon"));

    if (i > 0) {
      dist += haversineMeters(
        route[i - 1],
        { lat, lng }
      );
    }

    route.push({ lat, lng, dist });
  }

  gpxRoute = route;
  gpxTotalDistance = dist;
  gpxLoaded = true;
  lastSnapIndex = 0;
}

  function snapToGpxIndex(pos) {
  if (!gpxRoute) return null;

  const { AHEAD, BACK, EARLY_EXIT_METERS } = CONFIG.GPX_SEARCH;

  const start = Math.max(0, lastSnapIndex - BACK);
  const end = Math.min(
    gpxRoute.length - 1,
    lastSnapIndex + AHEAD
  );

  let best = lastSnapIndex;
  let bestDist = Infinity;

  for (let i = start; i <= end; i++) {
    const d = haversineMeters(pos, gpxRoute[i]);

    if (d < bestDist) {
      bestDist = d;
      best = i;
    }

    // Early exit once distance starts increasing
    if (i > lastSnapIndex && d > bestDist + EARLY_EXIT_METERS) {
      break;
    }
  }

  lastSnapIndex = best;

  return {
    point: gpxRoute[best],
    distance: bestDist
  };
}
  
function getVisualLatLng(rawPos) {
  if (!gpxLoaded) return rawPos;

  const snap = snapToGpxIndex(rawPos);

  // Only visually snap when reasonably close to route
  if (snap && snap.distance <= OFF_ROUTE_THRESHOLD_METERS) {
    return snap.point; // {lat, lng}
  }

  return rawPos;
}

function snapSubscriberToGpx(pos) {
  if (!gpxRoute) return null;

  let best = 0;
  let bestDist = Infinity;

  for (let i = 0; i < gpxRoute.length; i++) {
    const d = haversineMeters(pos, gpxRoute[i]);
    if (d < bestDist) {
      bestDist = d;
      best = i;
    }
  }

  return {
    point: gpxRoute[best],
    distance: bestDist
  };
}
  
  function pushFix(lat, lng, ts) {
  const last = recentFixes[recentFixes.length - 1];

  const dist = last
    ? haversineMeters(last, { lat, lng })
    : 0;

  recentFixes.push({
    lat,
    lng,
    ts,
    cumulative: (last?.cumulative || 0) + dist
  });

  // Trim to motion window
  const cutoff = ts - MOTION_WINDOW_MS;
  while (recentFixes.length && recentFixes[0].ts < cutoff) {
    recentFixes.shift();
  }
}

/* ---------- INIT ---------- */
async function init(){
  const data = await loadJSON(apiUrl);

  // üî¥ LOG ANALYTICS VIEW (ONCE PER PAGE LOAD)
fetch(
  apiUrl +
    "?function=logView" +
    "&source=tracker" +
    "&route=" +
    encodeURIComponent((data.routes || [])[0]?.routeName || "") +
    "&ua=" +
    encodeURIComponent(navigator.userAgent),
  { keepalive: true }
).catch(() => {});
  
  const s = data.settings || {};

  // üîë Capture Firebase base URL from API
  firebaseBaseUrl = data.tracker?.firebase_url || null;
  
  // ---------- TODAY'S ROUTE / GPX ----------
const today = new Date().toISOString().slice(0, 10);

const todayRoute = (data.routes || []).find(r =>
  r.date === today && r.gpxUrl
);

// Hide Notify button if no GPX route today
if (!todayRoute) {
  notifyBtn.style.display = "none";
} else {
  try {
    await loadGpxRoute(todayRoute.gpxUrl);
    console.log(
      "GPX loaded:",
      gpxTotalDistance.toFixed(0),
      "meters"
    );
  } catch (e) {
    console.warn("GPX disabled:", e.message);
    notifyBtn.style.display = "none";
  }
}

  // ---------- MAP ----------
map = L.map("map").setView(LAPLAND, 5);
L.tileLayer(
  "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
  { maxZoom: 19 }
).addTo(map);

  // ---------- VISUAL GPX OVERLAY (PURELY VISUAL) ----------
if (todayRoute && gpxLoaded) {
  const gpxLayer = new L.GPX(todayRoute.gpxUrl, {
    async: true,
    polyline_options: {
      color: s.accent_color || "#ffd700",
      weight: 4,
      opacity: 0.85
    },
    marker_options: {
      startIcon: L.icon({
        iconUrl: s.sleigh_icon_start || FALLBACK.start,
        iconSize: [48, 48],
        iconAnchor: [24, 48]
      }),
      endIcon: L.icon({
        iconUrl: s.sleigh_icon_end || FALLBACK.end,
        iconSize: [48, 48],
        iconAnchor: [24, 48]
      }),
      shadowUrl: null
    }
  });

  gpxLayer.addTo(map);
}

/* ‚úÖ RESTORE SAVED NOTIFY PIN */
const savedPin = sessionStorage.getItem("SANTA_NOTIFY_POINT");
if (savedPin) {
  try {
    const p = JSON.parse(savedPin);

    // üîÑ Reset browser notification state on reload
    browserNotified = false;
    sessionStorage.removeItem("SANTA_BROWSER_NOTIFIED");

    showNotifyMarker(p.lat, p.lng, true);
  } catch {}
}

  map.on("click", e => {
  if (!awaitingPin) return;

  const { lat, lng } = e.latlng;
  
  // Different spot ‚Üí MOVE preview
  pinPreview = { lat, lng };
  showNotifyMarker(lat, lng, false);

  statusBox.textContent =
    "üìç Pin moved ‚Äî tap again to confirm";
});

  if (s.logo_overlay_url) {

  // Map Sheet values ‚Üí Leaflet positions
  const LOGO_POSITIONS = {
    "top-left": "topleft",
    "top-right": "topright",
    "bottom-left": "bottomleft",
    "bottom-right": "bottomright",
    "center": "topright" // fallback (Leaflet has no true center)
  };

  const logoPosition =
    LOGO_POSITIONS[s.logo_overlay_position] || "bottomright";

  const LogoControl = L.control({ position: logoPosition });

  LogoControl.onAdd = function(){
    const img = L.DomUtil.create("img");
    img.src = s.logo_overlay_url;
    img.className = "logo-overlay";
    return img;
  };

  LogoControl.addTo(map);
}

  marker = L.marker(LAPLAND,{
    icon:L.icon({
      iconUrl:s.sleigh_icon_live||FALLBACK.live,
      iconSize:[64,64],
      iconAnchor:[32,60]
    })
  }).addTo(map);

  followBtn.onclick=()=>{follow=!follow;followBtn.textContent="Follow: "+(follow?"ON":"OFF")};
  recenterBtn.onclick=()=>{follow=true;map.panTo(marker.getLatLng())};

  loadingCover.style.display="none";

  tick();
}

/* ---------- POLL ---------- */
  async function tick(){
  const dot=statusDot;
  try{
    const p=await loadJSON(apiUrl+"?function=proxyFirebase");
    if(!valid(p.lat,p.lng)) throw 0;
    const ts = new Date(p.ts).getTime();
    
const age = Date.now() - ts;

/* ---------- STALE / FRESH CHECK ---------- */
const gpsFresh = age <= STALE_MS;

/* ---------- SUNSET / NIGHT MODE ---------- */
if (gpsFresh && isAfterSunset(p.lat, p.lng)) {
  document.body.classList.add("night-mode");
} else {
  document.body.classList.remove("night-mode");
}
    
/* ---------- STALE HANDLING ---------- */
if (age <= STALE_MS) {
  // ‚úÖ Fresh GPS
  staleSince = null;
  lastGoodFix = { lat: p.lat, lng: p.lng };

} else {
  // ‚ö†Ô∏è GPS already stale
  if (!staleSince) staleSince = ts;

  if (Date.now() - staleSince > STALE_MS) {
    throw 0;
  }

  if (lastGoodFix) {
    marker.setLatLng(lastGoodFix);
    statusBox.textContent = "üéÖ Santa is nearby‚Ä¶";
    setTimeout(tick, REFRESH);
    return;
  }
}

    const visualPos = getVisualLatLng({ lat: p.lat, lng: p.lng });
const ll = L.latLng(visualPos.lat, visualPos.lng);
animateMarkerTo(ll);


 // ---------- TRACK MOTION HISTORY ----------
const now = Date.now();
pushFix(p.lat, p.lng, now);

    // ---------- GPX ETA ----------
let etaSeconds = Infinity;
let offRoute = false;
let passedSubscriber = false;

if (gpxLoaded) {
  const santaPos = { lat: p.lat, lng: p.lng };
  const snap = snapToGpxIndex(santaPos);

  if (snap && snap.distance <= OFF_ROUTE_THRESHOLD_METERS) {

    // üîî If user subscribed, check if Santa already passed them
    if (notifyMarker) {
      const userPos = notifyMarker.getLatLng();
      const userSnap = snapSubscriberToGpx(userPos);

      if (userSnap && snap.point.dist > userSnap.point.dist + 30) {
        passedSubscriber = true;
      }
    }

    if (!passedSubscriber) {
      const remainingMeters = Math.max(
        0,
        gpxTotalDistance - snap.point.dist
      );

      const speed = calculateStableSpeedMps_(recentFixes);
      const moving = isSleighMoving();

if (speed !== null && moving && gpsFresh) {
  etaSeconds = remainingMeters / speed;
}

    }

  } else {
    offRoute = true;
  }
}
    
    // ---------- SNOW (Dynamic Intensity) ----------
    const night = document.body.classList.contains("night-mode");
    const etaMinutes = isFinite(etaSeconds) ? etaSeconds / 60 : Infinity;
    
    // Default: Off
    let snowOn = false;
    let snowLevel = 1;

    // Only snow if: Fresh Data + Night Time + Moving + Close enough
    if (gpsFresh && night && isSleighMoving() && etaMinutes < 15) {
      snowOn = true;

      if (etaMinutes < 2) {
        snowLevel = 3; // ‚ùÑÔ∏è BLIZZARD (0-2 mins)
      } else if (etaMinutes < 7) {
        snowLevel = 2; // üå®Ô∏è HEAVY (2-7 mins)
      } else {
        snowLevel = 1; // üåßÔ∏è LIGHT (7-15 mins)
      }
    }

    const { maxLevel } = getSnowThrottle();
setSnow(snowOn, Math.min(snowLevel, maxLevel));

    // üîî Browser notification backup (page-open only)
if (
  notifyMarker &&
  !browserNotified &&
  !passedSubscriber
) {
  const santa = { lat: p.lat, lng: p.lng };
  const user = notifyMarker.getLatLng();

  const meters = haversineMeters(santa, user);

  // ~250m ‚âà ~5 minutes at sleigh pace
  if (meters < 250) {
  browserNotified = true;
  sessionStorage.setItem("SANTA_BROWSER_NOTIFIED", "1");

  fireBrowserNotification(
    "üéÖ Santa is nearly here!",
    "He‚Äôs about 5 minutes away ‚Äî get ready! üéÑ"
  );
}
}
    
    if (firstFix) {
  map.setView(ll, 16);
  firstFix = false;
}

    const moving = isSleighMoving();

dot.style.display = "block";
dot.className = moving
  ? "status-dot dot-moving"
  : "status-dot dot-stopped";

if (passedSubscriber) {
  statusBox.textContent = "üéÑ Santa has just been here!";
  setDimUI(false);

} else if (isFinite(etaSeconds)) {
  const mins = Math.round(etaSeconds / 60);
  setDimUI(mins > 45);

  if (mins > 45) {
    statusBox.textContent = "üéÖ Santa is out delivering this evening‚Ä¶";

  } else if (mins > 15) {
    statusBox.textContent = "üéÖ Santa is on the way‚Ä¶";

  } else if (mins > 5) {
    statusBox.textContent = "üéÖ Santa is nearly here!";

  } else {
    statusBox.textContent =
      `üéÖ Santa is ${Math.max(1, mins)} min away!`;
  }

} else if (offRoute && moving) {
  setDimUI(false);
  statusBox.textContent = "üéÖ Santa is nearby‚Ä¶";

} else if (moving) {
  setDimUI(false);
  statusBox.textContent = "üéÖ Santa is out spreading joy!";

} else {
  setDimUI(false);
  statusBox.textContent = "üéÑ Santa has stopped to spread cheer!";
}

  }catch{
    marker.setLatLng(LAPLAND);
if (follow) map.setView(LAPLAND,5,{animate:true,duration:2});
dot.style.display="none";
    setDimUI(false);
statusBox.textContent="üéÑ Santa is in Lapland preparing for Christmas!";
firstFix=true;
    if (animRaf) cancelAnimationFrame(animRaf);
animRaf = null;
animCurrent = null;
animTarget = null;

  }
  setTimeout(tick,REFRESH);
}

init();

/* ===================================================
   NOTIFICATION SIGN-UP (STEP 1)
=================================================== */

notifyBtn.onclick = () => {
  follow = false;
  followBtn.textContent = "Follow: OFF";

  document.addEventListener("keydown", function esc(e) {
  if (e.key === "Escape" && awaitingPin) {
    awaitingPin = false;
    if (notifyMarker) map.removeLayer(notifyMarker);
    statusBox.textContent = "";
    document.removeEventListener("keydown", esc);
  }
});

  browserNotified = false;
  sessionStorage.removeItem("SANTA_BROWSER_NOTIFIED");
  sessionStorage.removeItem("SANTA_EMAIL_SUBSCRIBED");
  sessionStorage.removeItem("SANTA_NOTIFY_POINT");

  if ("Notification" in window && Notification.permission === "default") {
    Notification.requestPermission();
  }

  awaitingPin = true;
  pinPreview = null;

  statusBox.textContent =
    "üìç Tap the map to place your pin, then tap the pin to confirm";
};

function subscribeUser(lat, lng) {

  // ‚úÖ DUPLICATE GUARD
  if (sessionStorage.getItem("SANTA_EMAIL_SUBSCRIBED") === "1") {
    alert("üéÖ You‚Äôre already signed up for notifications!");
    return;
  }

  if (!firebaseBaseUrl) {
    alert("Notifications are not available for this tracker");
    return;
  }

  const email = prompt(
    "üìß Enter your email to be notified when Santa is close (recommended so you don‚Äôt miss him):"
  );

  showNotifyMarker(lat, lng, true);

  fetch(`${firebaseBaseUrl}/subscribers.json`, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    api: apiUrl,
    lat,
    lng,
    email: email || null,
    threshold_minutes: 5,
    notified: false,
    created: new Date().toISOString()
  })
})
.then(() => {
  sessionStorage.setItem("SANTA_EMAIL_SUBSCRIBED", "1");

  if (email) {
    alert("üéÖ You're signed up! We‚Äôll email you when Santa is close.");
  } else {
    alert(
      "üéÖ You're signed up!\n\n" +
      "‚ö†Ô∏è Keep this page open to receive the notification.\n" +
      "For guaranteed alerts next time, add your email."
    );
  }
})
.catch(() => {
  alert("‚ùå Could not save notification ‚Äî please try again.");
});
}
  
</script>
</body>
</html>
